// Code generated by VDL v0.4.0-alpha.5. DO NOT EDIT.
// If you edit this file, it will be overwritten the next time it is generated.
//
// For more information about VDL, visit https://vdl.varavel.com

/* eslint-disable */
/* tslint:disable */
// biome-ignore-all lint: Generated by VDL

// -----------------------------------------------------------------------------
// Enumerations
// -----------------------------------------------------------------------------

/**
 * Underlying storage kind used by an enum
 */
export type EnumType = "string" | "int";

export const EnumTypeList: EnumType[] = [
  "string",
  "int",
];

export function isEnumType(value: unknown): value is EnumType {
  return EnumTypeList.includes(value as EnumType);
}

/**
 * Primitive scalar type names
 */
export type PrimitiveType = "string" | "int" | "float" | "bool" | "datetime";

export const PrimitiveTypeList: PrimitiveType[] = [
  "string",
  "int",
  "float",
  "bool",
  "datetime",
];

export function isPrimitiveType(value: unknown): value is PrimitiveType {
  return PrimitiveTypeList.includes(value as PrimitiveType);
}

/**
 * Kind discriminator for TypeRef
 */
export type TypeKind = "primitive" | "type" | "enum" | "array" | "map" | "object";

export const TypeKindList: TypeKind[] = [
  "primitive",
  "type",
  "enum",
  "array",
  "map",
  "object",
];

export function isTypeKind(value: unknown): value is TypeKind {
  return TypeKindList.includes(value as TypeKind);
}

/**
 * Import extension options for TypeScript target
 */
export type TypescriptTargetImportExtension = "none" | ".js" | ".ts";

export const TypescriptTargetImportExtensionList: TypescriptTargetImportExtension[] = [
  "none",
  ".js",
  ".ts",
];

export function isTypescriptTargetImportExtension(value: unknown): value is TypescriptTargetImportExtension {
  return TypescriptTargetImportExtensionList.includes(value as TypescriptTargetImportExtension);
}

/**
 * Kind discriminator for Value.
 * 
 * Value is used for fully resolved literal data in:
 * - constant values
 * - annotation arguments
 */
export type ValueKind = "string" | "int" | "float" | "bool" | "object" | "array";

export const ValueKindList: ValueKind[] = [
  "string",
  "int",
  "float",
  "bool",
  "object",
  "array",
];

export function isValueKind(value: unknown): value is ValueKind {
  return ValueKindList.includes(value as ValueKind);
}

/**
 * Represents a function to be called via WASM
 */
export type WasmFunctionName = "ExpandTypes" | "ExtractType" | "ExtractProc" | "ExtractStream" | "Irgen" | "Codegen";

export const WasmFunctionNameList: WasmFunctionName[] = [
  "ExpandTypes",
  "ExtractType",
  "ExtractProc",
  "ExtractStream",
  "Irgen",
  "Codegen",
];

export function isWasmFunctionName(value: unknown): value is WasmFunctionName {
  return WasmFunctionNameList.includes(value as WasmFunctionName);
}

// -----------------------------------------------------------------------------
// Domain Types
// -----------------------------------------------------------------------------

/**
 * Annotation Annotation metadata preserved in IR.
 * 
 * `name` is the annotation identifier without the `@` prefix.
 * `argument`, when present, is fully resolved as a Value.
 */
export type Annotation = {
  name: string
  argument?: Value
}

export function hydrateAnnotation(input: Annotation): Annotation {
  const hydratedName = input.name
  const hydratedArgument = input.argument ? hydrateValue(input.argument) : input.argument
  return {
    name: hydratedName,
    argument: hydratedArgument,
  }
}

export function validateAnnotation(input: unknown, path = "Annotation"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.argument !== undefined && obj.argument !== null) {
    {
      const err = validateValue(obj.argument, `${path}.argument`);
      if (err !== null) return err;
    }
  }
  return null;
}

/**
 * ClientTargetConfig Configuration for generating RPC clients
 */
export type ClientTargetConfig = {
  genClient?: boolean
}

export function hydrateClientTargetConfig(input: ClientTargetConfig): ClientTargetConfig {
  const hydratedGenClient = input.genClient ? input.genClient : input.genClient
  return {
    genClient: hydratedGenClient,
  }
}

export function validateClientTargetConfig(_input: unknown, _path = "ClientTargetConfig"): string | null {
  return null;
}

/**
 * CodegenInput Input for codegen function
 */
export type CodegenInput = {
  vdlSchema: string
  target: TargetConfig
}

export function hydrateCodegenInput(input: CodegenInput): CodegenInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedTarget = hydrateTargetConfig(input.target)
  return {
    vdlSchema: hydratedVdlSchema,
    target: hydratedTarget,
  }
}

export function validateCodegenInput(input: unknown, path = "CodegenInput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.target === undefined || obj.target === null) {
    return `${path}.target: required field is missing`;
  }
  {
    const err = validateTargetConfig(obj.target, `${path}.target`);
    if (err !== null) return err;
  }
  return null;
}

/**
 * CodegenOutput Output for codegen function
 */
export type CodegenOutput = {
  files: CodegenOutputFile[]
}

export function hydrateCodegenOutput(input: CodegenOutput): CodegenOutput {
  const hydratedFiles = input.files.map(el => hydrateCodegenOutputFile(el))
  return {
    files: hydratedFiles,
  }
}

export function validateCodegenOutput(input: unknown, path = "CodegenOutput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.files === undefined || obj.files === null) {
    return `${path}.files: required field is missing`;
  }
  {
    if (!Array.isArray(obj.files)) {
      return `${path}.files: expected array, got ${typeof obj.files}`;
    }
    for (let i = 0; i < obj.files.length; i++) {
      {
        const err = validateCodegenOutputFile(obj.files[i], `${path}.files[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * CodegenOutputFile Rrepresents a file generated by codegen function
 */
export type CodegenOutputFile = {
  path: string
  content: string
}

export function hydrateCodegenOutputFile(input: CodegenOutputFile): CodegenOutputFile {
  const hydratedPath = input.path
  const hydratedContent = input.content
  return {
    path: hydratedPath,
    content: hydratedContent,
  }
}

export function validateCodegenOutputFile(_input: unknown, _path = "CodegenOutputFile"): string | null {
  return null;
}

/**
 * CommonTargetConfig Common configuration fields shared by all targets
 */
export type CommonTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
}

export function hydrateCommonTargetConfig(input: CommonTargetConfig): CommonTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
  }
}

export function validateCommonTargetConfig(_input: unknown, _path = "CommonTargetConfig"): string | null {
  return null;
}

/**
 * ConstantDef Fully resolved constant definition.
 * 
 * `typeRef` is explicit or inferred by analysis.
 * `value` contains the fully resolved literal payload.
 */
export type ConstantDef = {
  name: string
  doc?: string
  annotations: Annotation[]
  typeRef: TypeRef
  value: Value
}

export function hydrateConstantDef(input: ConstantDef): ConstantDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedAnnotations = input.annotations.map(el => hydrateAnnotation(el))
  const hydratedTypeRef = hydrateTypeRef(input.typeRef)
  const hydratedValue = hydrateValue(input.value)
  return {
    name: hydratedName,
    doc: hydratedDoc,
    annotations: hydratedAnnotations,
    typeRef: hydratedTypeRef,
    value: hydratedValue,
  }
}

export function validateConstantDef(input: unknown, path = "ConstantDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.annotations === undefined || obj.annotations === null) {
    return `${path}.annotations: required field is missing`;
  }
  {
    if (!Array.isArray(obj.annotations)) {
      return `${path}.annotations: expected array, got ${typeof obj.annotations}`;
    }
    for (let i = 0; i < obj.annotations.length; i++) {
      {
        const err = validateAnnotation(obj.annotations[i], `${path}.annotations[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.typeRef === undefined || obj.typeRef === null) {
    return `${path}.typeRef: required field is missing`;
  }
  {
    const err = validateTypeRef(obj.typeRef, `${path}.typeRef`);
    if (err !== null) return err;
  }
  if (obj.value === undefined || obj.value === null) {
    return `${path}.value: required field is missing`;
  }
  {
    const err = validateValue(obj.value, `${path}.value`);
    if (err !== null) return err;
  }
  return null;
}

/**
 * ConstsTargetConfig Configuration for generating constants
 */
export type ConstsTargetConfig = {
  genConsts?: boolean
}

export function hydrateConstsTargetConfig(input: ConstsTargetConfig): ConstsTargetConfig {
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  return {
    genConsts: hydratedGenConsts,
  }
}

export function validateConstsTargetConfig(_input: unknown, _path = "ConstsTargetConfig"): string | null {
  return null;
}

/**
 * DartTargetConfig Configuration for Dart code generation
 */
export type DartTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
}

export function hydrateDartTargetConfig(input: DartTargetConfig): DartTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
  }
}

export function validateDartTargetConfig(_input: unknown, _path = "DartTargetConfig"): string | null {
  return null;
}

/**
 * DocDef Standalone documentation block.
 * 
 * Used for top-level docstrings that are not attached to a type/enum/constant.
 */
export type DocDef = {
  content: string
}

export function hydrateDocDef(input: DocDef): DocDef {
  const hydratedContent = input.content
  return {
    content: hydratedContent,
  }
}

export function validateDocDef(_input: unknown, _path = "DocDef"): string | null {
  return null;
}

/**
 * EnumDef Flattened enum definition.
 * 
 * All enum spreads are already expanded into `members`.
 */
export type EnumDef = {
  name: string
  doc?: string
  annotations: Annotation[]
  enumType: EnumType
  members: EnumDefMember[]
}

export function hydrateEnumDef(input: EnumDef): EnumDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedAnnotations = input.annotations.map(el => hydrateAnnotation(el))
  const hydratedEnumType = input.enumType
  const hydratedMembers = input.members.map(el => hydrateEnumDefMember(el))
  return {
    name: hydratedName,
    doc: hydratedDoc,
    annotations: hydratedAnnotations,
    enumType: hydratedEnumType,
    members: hydratedMembers,
  }
}

export function validateEnumDef(input: unknown, path = "EnumDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.annotations === undefined || obj.annotations === null) {
    return `${path}.annotations: required field is missing`;
  }
  {
    if (!Array.isArray(obj.annotations)) {
      return `${path}.annotations: expected array, got ${typeof obj.annotations}`;
    }
    for (let i = 0; i < obj.annotations.length; i++) {
      {
        const err = validateAnnotation(obj.annotations[i], `${path}.annotations[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.enumType === undefined || obj.enumType === null) {
    return `${path}.enumType: required field is missing`;
  }
  {
    if (!isEnumType(obj.enumType)) {
      return `${path}.enumType: invalid enum value '${obj.enumType}' for EnumType`;
    }
  }
  if (obj.members === undefined || obj.members === null) {
    return `${path}.members: required field is missing`;
  }
  {
    if (!Array.isArray(obj.members)) {
      return `${path}.members: expected array, got ${typeof obj.members}`;
    }
    for (let i = 0; i < obj.members.length; i++) {
      {
        const err = validateEnumDefMember(obj.members[i], `${path}.members[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * EnumDefMember Enum member definition
 */
export type EnumDefMember = {
  name: string
  value: string
  doc?: string
  annotations: Annotation[]
}

export function hydrateEnumDefMember(input: EnumDefMember): EnumDefMember {
  const hydratedName = input.name
  const hydratedValue = input.value
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedAnnotations = input.annotations.map(el => hydrateAnnotation(el))
  return {
    name: hydratedName,
    value: hydratedValue,
    doc: hydratedDoc,
    annotations: hydratedAnnotations,
  }
}

export function validateEnumDefMember(input: unknown, path = "EnumDefMember"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.annotations === undefined || obj.annotations === null) {
    return `${path}.annotations: required field is missing`;
  }
  {
    if (!Array.isArray(obj.annotations)) {
      return `${path}.annotations: expected array, got ${typeof obj.annotations}`;
    }
    for (let i = 0; i < obj.annotations.length; i++) {
      {
        const err = validateAnnotation(obj.annotations[i], `${path}.annotations[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * ExpandTypesInput Input for expandTypes function
 */
export type ExpandTypesInput = {
  vdlSchema: string
}

export function hydrateExpandTypesInput(input: ExpandTypesInput): ExpandTypesInput {
  const hydratedVdlSchema = input.vdlSchema
  return {
    vdlSchema: hydratedVdlSchema,
  }
}

export function validateExpandTypesInput(_input: unknown, _path = "ExpandTypesInput"): string | null {
  return null;
}

/**
 * ExpandTypesOutput Output for expandTypes function
 */
export type ExpandTypesOutput = {
  expandedSchema: string
}

export function hydrateExpandTypesOutput(input: ExpandTypesOutput): ExpandTypesOutput {
  const hydratedExpandedSchema = input.expandedSchema
  return {
    expandedSchema: hydratedExpandedSchema,
  }
}

export function validateExpandTypesOutput(_input: unknown, _path = "ExpandTypesOutput"): string | null {
  return null;
}

/**
 * ExtractProcInput Input for extractProc function
 */
export type ExtractProcInput = {
  vdlSchema: string
  rpcName: string
  procName: string
}

export function hydrateExtractProcInput(input: ExtractProcInput): ExtractProcInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedRpcName = input.rpcName
  const hydratedProcName = input.procName
  return {
    vdlSchema: hydratedVdlSchema,
    rpcName: hydratedRpcName,
    procName: hydratedProcName,
  }
}

export function validateExtractProcInput(_input: unknown, _path = "ExtractProcInput"): string | null {
  return null;
}

/**
 * ExtractProcOutput Output for extractProc function
 */
export type ExtractProcOutput = {
  procSchema: string
}

export function hydrateExtractProcOutput(input: ExtractProcOutput): ExtractProcOutput {
  const hydratedProcSchema = input.procSchema
  return {
    procSchema: hydratedProcSchema,
  }
}

export function validateExtractProcOutput(_input: unknown, _path = "ExtractProcOutput"): string | null {
  return null;
}

/**
 * ExtractStreamInput Input for extractStream function
 */
export type ExtractStreamInput = {
  vdlSchema: string
  rpcName: string
  streamName: string
}

export function hydrateExtractStreamInput(input: ExtractStreamInput): ExtractStreamInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedRpcName = input.rpcName
  const hydratedStreamName = input.streamName
  return {
    vdlSchema: hydratedVdlSchema,
    rpcName: hydratedRpcName,
    streamName: hydratedStreamName,
  }
}

export function validateExtractStreamInput(_input: unknown, _path = "ExtractStreamInput"): string | null {
  return null;
}

/**
 * ExtractStreamOutput Output for extractStream function
 */
export type ExtractStreamOutput = {
  streamSchema: string
}

export function hydrateExtractStreamOutput(input: ExtractStreamOutput): ExtractStreamOutput {
  const hydratedStreamSchema = input.streamSchema
  return {
    streamSchema: hydratedStreamSchema,
  }
}

export function validateExtractStreamOutput(_input: unknown, _path = "ExtractStreamOutput"): string | null {
  return null;
}

/**
 * ExtractTypeInput Input for extractType function
 */
export type ExtractTypeInput = {
  vdlSchema: string
  typeName: string
}

export function hydrateExtractTypeInput(input: ExtractTypeInput): ExtractTypeInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedTypeName = input.typeName
  return {
    vdlSchema: hydratedVdlSchema,
    typeName: hydratedTypeName,
  }
}

export function validateExtractTypeInput(_input: unknown, _path = "ExtractTypeInput"): string | null {
  return null;
}

/**
 * ExtractTypeOutput Output for extractType function
 */
export type ExtractTypeOutput = {
  typeSchema: string
}

export function hydrateExtractTypeOutput(input: ExtractTypeOutput): ExtractTypeOutput {
  const hydratedTypeSchema = input.typeSchema
  return {
    typeSchema: hydratedTypeSchema,
  }
}

export function validateExtractTypeOutput(_input: unknown, _path = "ExtractTypeOutput"): string | null {
  return null;
}

/**
 * Field Flattened object/type field definition
 */
export type Field = {
  name: string
  doc?: string
  optional: boolean
  annotations: Annotation[]
  typeRef: TypeRef
}

export function hydrateField(input: Field): Field {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedOptional = input.optional
  const hydratedAnnotations = input.annotations.map(el => hydrateAnnotation(el))
  const hydratedTypeRef = hydrateTypeRef(input.typeRef)
  return {
    name: hydratedName,
    doc: hydratedDoc,
    optional: hydratedOptional,
    annotations: hydratedAnnotations,
    typeRef: hydratedTypeRef,
  }
}

export function validateField(input: unknown, path = "Field"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.annotations === undefined || obj.annotations === null) {
    return `${path}.annotations: required field is missing`;
  }
  {
    if (!Array.isArray(obj.annotations)) {
      return `${path}.annotations: expected array, got ${typeof obj.annotations}`;
    }
    for (let i = 0; i < obj.annotations.length; i++) {
      {
        const err = validateAnnotation(obj.annotations[i], `${path}.annotations[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.typeRef === undefined || obj.typeRef === null) {
    return `${path}.typeRef: required field is missing`;
  }
  {
    const err = validateTypeRef(obj.typeRef, `${path}.typeRef`);
    if (err !== null) return err;
  }
  return null;
}

/**
 * GoTargetConfig Configuration for Go code generation
 */
export type GoTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
  genClient?: boolean
  genServer?: boolean
  package: string
}

export function hydrateGoTargetConfig(input: GoTargetConfig): GoTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  const hydratedGenClient = input.genClient ? input.genClient : input.genClient
  const hydratedGenServer = input.genServer ? input.genServer : input.genServer
  const hydratedPackage = input.package
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
    genClient: hydratedGenClient,
    genServer: hydratedGenServer,
    package: hydratedPackage,
  }
}

export function validateGoTargetConfig(_input: unknown, _path = "GoTargetConfig"): string | null {
  return null;
}

/**
 * IrSchema IrSchema is the generator-facing representation of a VDL program.
 * 
 * This model is intentionally "flat" and "resolved":
 * - spreads are already expanded
 * - references are already resolved
 * - collections are in deterministic order
 * 
 * A code generator should be able to consume IrSchema directly, without needing
 * to re-run parser or semantic-analysis logic.
 */
export type IrSchema = {
  constants: ConstantDef[]
  enums: EnumDef[]
  types: TypeDef[]
  docs: DocDef[]
}

export function hydrateIrSchema(input: IrSchema): IrSchema {
  const hydratedConstants = input.constants.map(el => hydrateConstantDef(el))
  const hydratedEnums = input.enums.map(el => hydrateEnumDef(el))
  const hydratedTypes = input.types.map(el => hydrateTypeDef(el))
  const hydratedDocs = input.docs.map(el => hydrateDocDef(el))
  return {
    constants: hydratedConstants,
    enums: hydratedEnums,
    types: hydratedTypes,
    docs: hydratedDocs,
  }
}

export function validateIrSchema(input: unknown, path = "IrSchema"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.constants === undefined || obj.constants === null) {
    return `${path}.constants: required field is missing`;
  }
  {
    if (!Array.isArray(obj.constants)) {
      return `${path}.constants: expected array, got ${typeof obj.constants}`;
    }
    for (let i = 0; i < obj.constants.length; i++) {
      {
        const err = validateConstantDef(obj.constants[i], `${path}.constants[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.enums === undefined || obj.enums === null) {
    return `${path}.enums: required field is missing`;
  }
  {
    if (!Array.isArray(obj.enums)) {
      return `${path}.enums: expected array, got ${typeof obj.enums}`;
    }
    for (let i = 0; i < obj.enums.length; i++) {
      {
        const err = validateEnumDef(obj.enums[i], `${path}.enums[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.types === undefined || obj.types === null) {
    return `${path}.types: required field is missing`;
  }
  {
    if (!Array.isArray(obj.types)) {
      return `${path}.types: expected array, got ${typeof obj.types}`;
    }
    for (let i = 0; i < obj.types.length; i++) {
      {
        const err = validateTypeDef(obj.types[i], `${path}.types[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.docs === undefined || obj.docs === null) {
    return `${path}.docs: required field is missing`;
  }
  {
    if (!Array.isArray(obj.docs)) {
      return `${path}.docs: expected array, got ${typeof obj.docs}`;
    }
    for (let i = 0; i < obj.docs.length; i++) {
      {
        const err = validateDocDef(obj.docs[i], `${path}.docs[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * IrTargetConfig Configuration for IR (Intermediate Representation) JSON generation
 */
export type IrTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  filename?: string
  minify?: boolean
}

export function hydrateIrTargetConfig(input: IrTargetConfig): IrTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedFilename = input.filename ? input.filename : input.filename
  const hydratedMinify = input.minify ? input.minify : input.minify
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    filename: hydratedFilename,
    minify: hydratedMinify,
  }
}

export function validateIrTargetConfig(_input: unknown, _path = "IrTargetConfig"): string | null {
  return null;
}

/**
 * JsonSchemaTargetConfig Configuration for JSON Schema generation
 */
export type JsonSchemaTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  id?: string
  filename?: string
  root?: string
}

export function hydrateJsonSchemaTargetConfig(input: JsonSchemaTargetConfig): JsonSchemaTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedId = input.id ? input.id : input.id
  const hydratedFilename = input.filename ? input.filename : input.filename
  const hydratedRoot = input.root ? input.root : input.root
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    id: hydratedId,
    filename: hydratedFilename,
    root: hydratedRoot,
  }
}

export function validateJsonSchemaTargetConfig(_input: unknown, _path = "JsonSchemaTargetConfig"): string | null {
  return null;
}

/**
 * ObjectEntry Key/value pair inside an object Value payload
 */
export type ObjectEntry = {
  key: string
  value: Value
}

export function hydrateObjectEntry(input: ObjectEntry): ObjectEntry {
  const hydratedKey = input.key
  const hydratedValue = hydrateValue(input.value)
  return {
    key: hydratedKey,
    value: hydratedValue,
  }
}

export function validateObjectEntry(input: unknown, path = "ObjectEntry"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.value === undefined || obj.value === null) {
    return `${path}.value: required field is missing`;
  }
  {
    const err = validateValue(obj.value, `${path}.value`);
    if (err !== null) return err;
  }
  return null;
}

/**
 * OpenApiTargetConfig Configuration for OpenAPI specification generation
 */
export type OpenApiTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  filename?: string
  title: string
  version: string
  description?: string
  baseUrl?: string
  contactName?: string
  contactEmail?: string
  licenseName?: string
}

export function hydrateOpenApiTargetConfig(input: OpenApiTargetConfig): OpenApiTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedFilename = input.filename ? input.filename : input.filename
  const hydratedTitle = input.title
  const hydratedVersion = input.version
  const hydratedDescription = input.description ? input.description : input.description
  const hydratedBaseUrl = input.baseUrl ? input.baseUrl : input.baseUrl
  const hydratedContactName = input.contactName ? input.contactName : input.contactName
  const hydratedContactEmail = input.contactEmail ? input.contactEmail : input.contactEmail
  const hydratedLicenseName = input.licenseName ? input.licenseName : input.licenseName
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    filename: hydratedFilename,
    title: hydratedTitle,
    version: hydratedVersion,
    description: hydratedDescription,
    baseUrl: hydratedBaseUrl,
    contactName: hydratedContactName,
    contactEmail: hydratedContactEmail,
    licenseName: hydratedLicenseName,
  }
}

export function validateOpenApiTargetConfig(_input: unknown, _path = "OpenApiTargetConfig"): string | null {
  return null;
}

/**
 * PatternsTargetConfig Configuration for generating patterns
 */
export type PatternsTargetConfig = {
  genPatterns?: boolean
}

export function hydratePatternsTargetConfig(input: PatternsTargetConfig): PatternsTargetConfig {
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  return {
    genPatterns: hydratedGenPatterns,
  }
}

export function validatePatternsTargetConfig(_input: unknown, _path = "PatternsTargetConfig"): string | null {
  return null;
}

/**
 * PlaygroundTargetConfig Configuration for API playground generation
 */
export type PlaygroundTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  defaultBaseUrl?: string
  defaultHeaders?: Record<string, string>
}

export function hydratePlaygroundTargetConfig(input: PlaygroundTargetConfig): PlaygroundTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedDefaultBaseUrl = input.defaultBaseUrl ? input.defaultBaseUrl : input.defaultBaseUrl
  const hydratedDefaultHeaders = input.defaultHeaders ? input.defaultHeaders : input.defaultHeaders
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    defaultBaseUrl: hydratedDefaultBaseUrl,
    defaultHeaders: hydratedDefaultHeaders,
  }
}

export function validatePlaygroundTargetConfig(_input: unknown, _path = "PlaygroundTargetConfig"): string | null {
  return null;
}

/**
 * PluginTargetConfig Configuration for external plugin generators
 */
export type PluginTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  command: string[]
  options?: Record<string, string>
}

export function hydratePluginTargetConfig(input: PluginTargetConfig): PluginTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedCommand = input.command
  const hydratedOptions = input.options ? input.options : input.options
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    command: hydratedCommand,
    options: hydratedOptions,
  }
}

export function validatePluginTargetConfig(_input: unknown, _path = "PluginTargetConfig"): string | null {
  return null;
}

/**
 * PythonTargetConfig Configuration for Python code generation
 */
export type PythonTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
}

export function hydratePythonTargetConfig(input: PythonTargetConfig): PythonTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
  }
}

export function validatePythonTargetConfig(_input: unknown, _path = "PythonTargetConfig"): string | null {
  return null;
}

/**
 * ServerTargetConfig Configuration for generating RPC servers
 */
export type ServerTargetConfig = {
  genServer?: boolean
}

export function hydrateServerTargetConfig(input: ServerTargetConfig): ServerTargetConfig {
  const hydratedGenServer = input.genServer ? input.genServer : input.genServer
  return {
    genServer: hydratedGenServer,
  }
}

export function validateServerTargetConfig(_input: unknown, _path = "ServerTargetConfig"): string | null {
  return null;
}

/**
 * TargetConfig Configuration for a specific generation target, only one target type should be set per entry
 */
export type TargetConfig = {
  go?: GoTargetConfig
  typescript?: TypeScriptTargetConfig
  dart?: DartTargetConfig
  python?: PythonTargetConfig
  jsonschema?: JsonSchemaTargetConfig
  openapi?: OpenApiTargetConfig
  playground?: PlaygroundTargetConfig
  plugin?: PluginTargetConfig
  ir?: IrTargetConfig
  vdl?: VdlTargetConfig
}

export function hydrateTargetConfig(input: TargetConfig): TargetConfig {
  const hydratedGo = input.go ? hydrateGoTargetConfig(input.go) : input.go
  const hydratedTypescript = input.typescript ? hydrateTypeScriptTargetConfig(input.typescript) : input.typescript
  const hydratedDart = input.dart ? hydrateDartTargetConfig(input.dart) : input.dart
  const hydratedPython = input.python ? hydratePythonTargetConfig(input.python) : input.python
  const hydratedJsonschema = input.jsonschema ? hydrateJsonSchemaTargetConfig(input.jsonschema) : input.jsonschema
  const hydratedOpenapi = input.openapi ? hydrateOpenApiTargetConfig(input.openapi) : input.openapi
  const hydratedPlayground = input.playground ? hydratePlaygroundTargetConfig(input.playground) : input.playground
  const hydratedPlugin = input.plugin ? hydratePluginTargetConfig(input.plugin) : input.plugin
  const hydratedIr = input.ir ? hydrateIrTargetConfig(input.ir) : input.ir
  const hydratedVdl = input.vdl ? hydrateVdlTargetConfig(input.vdl) : input.vdl
  return {
    go: hydratedGo,
    typescript: hydratedTypescript,
    dart: hydratedDart,
    python: hydratedPython,
    jsonschema: hydratedJsonschema,
    openapi: hydratedOpenapi,
    playground: hydratedPlayground,
    plugin: hydratedPlugin,
    ir: hydratedIr,
    vdl: hydratedVdl,
  }
}

export function validateTargetConfig(input: unknown, path = "TargetConfig"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.go !== undefined && obj.go !== null) {
    {
      const err = validateGoTargetConfig(obj.go, `${path}.go`);
      if (err !== null) return err;
    }
  }
  if (obj.typescript !== undefined && obj.typescript !== null) {
    {
      const err = validateTypeScriptTargetConfig(obj.typescript, `${path}.typescript`);
      if (err !== null) return err;
    }
  }
  if (obj.dart !== undefined && obj.dart !== null) {
    {
      const err = validateDartTargetConfig(obj.dart, `${path}.dart`);
      if (err !== null) return err;
    }
  }
  if (obj.python !== undefined && obj.python !== null) {
    {
      const err = validatePythonTargetConfig(obj.python, `${path}.python`);
      if (err !== null) return err;
    }
  }
  if (obj.jsonschema !== undefined && obj.jsonschema !== null) {
    {
      const err = validateJsonSchemaTargetConfig(obj.jsonschema, `${path}.jsonschema`);
      if (err !== null) return err;
    }
  }
  if (obj.openapi !== undefined && obj.openapi !== null) {
    {
      const err = validateOpenApiTargetConfig(obj.openapi, `${path}.openapi`);
      if (err !== null) return err;
    }
  }
  if (obj.playground !== undefined && obj.playground !== null) {
    {
      const err = validatePlaygroundTargetConfig(obj.playground, `${path}.playground`);
      if (err !== null) return err;
    }
  }
  if (obj.plugin !== undefined && obj.plugin !== null) {
    {
      const err = validatePluginTargetConfig(obj.plugin, `${path}.plugin`);
      if (err !== null) return err;
    }
  }
  if (obj.ir !== undefined && obj.ir !== null) {
    {
      const err = validateIrTargetConfig(obj.ir, `${path}.ir`);
      if (err !== null) return err;
    }
  }
  if (obj.vdl !== undefined && obj.vdl !== null) {
    {
      const err = validateVdlTargetConfig(obj.vdl, `${path}.vdl`);
      if (err !== null) return err;
    }
  }
  return null;
}

/**
 * TypeDef Flattened type definition.
 * 
 * All spreads are already expanded into `fields`.
 */
export type TypeDef = {
  name: string
  doc?: string
  annotations: Annotation[]
  fields: Field[]
}

export function hydrateTypeDef(input: TypeDef): TypeDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedAnnotations = input.annotations.map(el => hydrateAnnotation(el))
  const hydratedFields = input.fields.map(el => hydrateField(el))
  return {
    name: hydratedName,
    doc: hydratedDoc,
    annotations: hydratedAnnotations,
    fields: hydratedFields,
  }
}

export function validateTypeDef(input: unknown, path = "TypeDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.annotations === undefined || obj.annotations === null) {
    return `${path}.annotations: required field is missing`;
  }
  {
    if (!Array.isArray(obj.annotations)) {
      return `${path}.annotations: expected array, got ${typeof obj.annotations}`;
    }
    for (let i = 0; i < obj.annotations.length; i++) {
      {
        const err = validateAnnotation(obj.annotations[i], `${path}.annotations[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.fields === undefined || obj.fields === null) {
    return `${path}.fields: required field is missing`;
  }
  {
    if (!Array.isArray(obj.fields)) {
      return `${path}.fields: expected array, got ${typeof obj.fields}`;
    }
    for (let i = 0; i < obj.fields.length; i++) {
      {
        const err = validateField(obj.fields[i], `${path}.fields[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * TypeRef Normalized type reference used by fields and constants.
 * 
 * `kind` selects which payload fields are meaningful. Generators should inspect
 * `kind` first, then read the related payload fields.
 */
export type TypeRef = {
  kind: TypeKind
  primitiveName?: PrimitiveType
  typeName?: string
  enumName?: string
  enumType?: EnumType
  arrayType?: TypeRef
  arrayDims?: number
  mapType?: TypeRef
  objectFields?: Field[]
}

export function hydrateTypeRef(input: TypeRef): TypeRef {
  const hydratedKind = input.kind
  const hydratedPrimitiveName = input.primitiveName ? input.primitiveName : input.primitiveName
  const hydratedTypeName = input.typeName ? input.typeName : input.typeName
  const hydratedEnumName = input.enumName ? input.enumName : input.enumName
  const hydratedEnumType = input.enumType ? input.enumType : input.enumType
  const hydratedArrayType = input.arrayType ? hydrateTypeRef(input.arrayType) : input.arrayType
  const hydratedArrayDims = input.arrayDims ? input.arrayDims : input.arrayDims
  const hydratedMapType = input.mapType ? hydrateTypeRef(input.mapType) : input.mapType
  const hydratedObjectFields = input.objectFields ? input.objectFields.map(el => hydrateField(el)) : input.objectFields
  return {
    kind: hydratedKind,
    primitiveName: hydratedPrimitiveName,
    typeName: hydratedTypeName,
    enumName: hydratedEnumName,
    enumType: hydratedEnumType,
    arrayType: hydratedArrayType,
    arrayDims: hydratedArrayDims,
    mapType: hydratedMapType,
    objectFields: hydratedObjectFields,
  }
}

export function validateTypeRef(input: unknown, path = "TypeRef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.kind === undefined || obj.kind === null) {
    return `${path}.kind: required field is missing`;
  }
  {
    if (!isTypeKind(obj.kind)) {
      return `${path}.kind: invalid enum value '${obj.kind}' for TypeKind`;
    }
  }
  if (obj.primitiveName !== undefined && obj.primitiveName !== null) {
    {
      if (!isPrimitiveType(obj.primitiveName)) {
        return `${path}.primitiveName: invalid enum value '${obj.primitiveName}' for PrimitiveType`;
      }
    }
  }
  if (obj.enumType !== undefined && obj.enumType !== null) {
    {
      if (!isEnumType(obj.enumType)) {
        return `${path}.enumType: invalid enum value '${obj.enumType}' for EnumType`;
      }
    }
  }
  if (obj.arrayType !== undefined && obj.arrayType !== null) {
    {
      const err = validateTypeRef(obj.arrayType, `${path}.arrayType`);
      if (err !== null) return err;
    }
  }
  if (obj.mapType !== undefined && obj.mapType !== null) {
    {
      const err = validateTypeRef(obj.mapType, `${path}.mapType`);
      if (err !== null) return err;
    }
  }
  if (obj.objectFields !== undefined && obj.objectFields !== null) {
    {
      if (!Array.isArray(obj.objectFields)) {
        return `${path}.objectFields: expected array, got ${typeof obj.objectFields}`;
      }
      for (let i = 0; i < obj.objectFields.length; i++) {
        {
          const err = validateField(obj.objectFields[i], `${path}.objectFields[${i}]`);
          if (err !== null) return err;
        }
      }
    }
  }
  return null;
}

/**
 * TypeScriptTargetConfig Configuration for TypeScript code generation
 */
export type TypeScriptTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
  genClient?: boolean
  genServer?: boolean
  importExtension?: TypescriptTargetImportExtension
}

export function hydrateTypeScriptTargetConfig(input: TypeScriptTargetConfig): TypeScriptTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  const hydratedGenClient = input.genClient ? input.genClient : input.genClient
  const hydratedGenServer = input.genServer ? input.genServer : input.genServer
  const hydratedImportExtension = input.importExtension ? input.importExtension : input.importExtension
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
    genClient: hydratedGenClient,
    genServer: hydratedGenServer,
    importExtension: hydratedImportExtension,
  }
}

export function validateTypeScriptTargetConfig(input: unknown, path = "TypeScriptTargetConfig"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.importExtension !== undefined && obj.importExtension !== null) {
    {
      if (!isTypescriptTargetImportExtension(obj.importExtension)) {
        return `${path}.importExtension: invalid enum value '${obj.importExtension}' for TypescriptTargetImportExtension`;
      }
    }
  }
  return null;
}

/**
 * Value Fully resolved literal value.
 * 
 * The selected payload is determined by `kind`:
 * - `string` -> `stringValue`
 * - `int` -> `intValue`
 * - `float` -> `floatValue`
 * - `bool` -> `boolValue`
 * - `object` -> `objectEntries`
 * - `array` -> `arrayItems`
 */
export type Value = {
  kind: ValueKind
  stringValue?: string
  intValue?: number
  floatValue?: number
  boolValue?: boolean
  objectEntries?: ObjectEntry[]
  arrayItems?: Value[]
}

export function hydrateValue(input: Value): Value {
  const hydratedKind = input.kind
  const hydratedStringValue = input.stringValue ? input.stringValue : input.stringValue
  const hydratedIntValue = input.intValue ? input.intValue : input.intValue
  const hydratedFloatValue = input.floatValue ? input.floatValue : input.floatValue
  const hydratedBoolValue = input.boolValue ? input.boolValue : input.boolValue
  const hydratedObjectEntries = input.objectEntries ? input.objectEntries.map(el => hydrateObjectEntry(el)) : input.objectEntries
  const hydratedArrayItems = input.arrayItems ? input.arrayItems.map(el => hydrateValue(el)) : input.arrayItems
  return {
    kind: hydratedKind,
    stringValue: hydratedStringValue,
    intValue: hydratedIntValue,
    floatValue: hydratedFloatValue,
    boolValue: hydratedBoolValue,
    objectEntries: hydratedObjectEntries,
    arrayItems: hydratedArrayItems,
  }
}

export function validateValue(input: unknown, path = "Value"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.kind === undefined || obj.kind === null) {
    return `${path}.kind: required field is missing`;
  }
  {
    if (!isValueKind(obj.kind)) {
      return `${path}.kind: invalid enum value '${obj.kind}' for ValueKind`;
    }
  }
  if (obj.objectEntries !== undefined && obj.objectEntries !== null) {
    {
      if (!Array.isArray(obj.objectEntries)) {
        return `${path}.objectEntries: expected array, got ${typeof obj.objectEntries}`;
      }
      for (let i = 0; i < obj.objectEntries.length; i++) {
        {
          const err = validateObjectEntry(obj.objectEntries[i], `${path}.objectEntries[${i}]`);
          if (err !== null) return err;
        }
      }
    }
  }
  if (obj.arrayItems !== undefined && obj.arrayItems !== null) {
    {
      if (!Array.isArray(obj.arrayItems)) {
        return `${path}.arrayItems: expected array, got ${typeof obj.arrayItems}`;
      }
      for (let i = 0; i < obj.arrayItems.length; i++) {
        {
          const err = validateValue(obj.arrayItems[i], `${path}.arrayItems[${i}]`);
          if (err !== null) return err;
        }
      }
    }
  }
  return null;
}

/**
 * VdlCodegenConfig VDL Configuration Schema
 * 
 * This schema defines the configuration format for the VDL code generator (vdl.yaml)
 * 
 * It supports multiple target languages and output formats
 */
export type VdlCodegenConfig = {
  version: number
  schema?: string
  targets: TargetConfig[]
}

export function hydrateVdlCodegenConfig(input: VdlCodegenConfig): VdlCodegenConfig {
  const hydratedVersion = input.version
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedTargets = input.targets.map(el => hydrateTargetConfig(el))
  return {
    version: hydratedVersion,
    schema: hydratedSchema,
    targets: hydratedTargets,
  }
}

export function validateVdlCodegenConfig(input: unknown, path = "VdlCodegenConfig"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.targets === undefined || obj.targets === null) {
    return `${path}.targets: required field is missing`;
  }
  {
    if (!Array.isArray(obj.targets)) {
      return `${path}.targets: expected array, got ${typeof obj.targets}`;
    }
    for (let i = 0; i < obj.targets.length; i++) {
      {
        const err = validateTargetConfig(obj.targets[i], `${path}.targets[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * VdlTargetConfig Configuration for unified VDL schema generation (merges all includes and external docs)
 */
export type VdlTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  filename?: string
}

export function hydrateVdlTargetConfig(input: VdlTargetConfig): VdlTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedFilename = input.filename ? input.filename : input.filename
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    filename: hydratedFilename,
  }
}

export function validateVdlTargetConfig(_input: unknown, _path = "VdlTargetConfig"): string | null {
  return null;
}

/**
 * WasmInput The input for the WASM function call
 */
export type WasmInput = {
  functionName: WasmFunctionName
  expandTypes?: ExpandTypesInput
  extractType?: ExtractTypeInput
  extractProc?: ExtractProcInput
  extractStream?: ExtractStreamInput
  codegen?: CodegenInput
}

export function hydrateWasmInput(input: WasmInput): WasmInput {
  const hydratedFunctionName = input.functionName
  const hydratedExpandTypes = input.expandTypes ? hydrateExpandTypesInput(input.expandTypes) : input.expandTypes
  const hydratedExtractType = input.extractType ? hydrateExtractTypeInput(input.extractType) : input.extractType
  const hydratedExtractProc = input.extractProc ? hydrateExtractProcInput(input.extractProc) : input.extractProc
  const hydratedExtractStream = input.extractStream ? hydrateExtractStreamInput(input.extractStream) : input.extractStream
  const hydratedCodegen = input.codegen ? hydrateCodegenInput(input.codegen) : input.codegen
  return {
    functionName: hydratedFunctionName,
    expandTypes: hydratedExpandTypes,
    extractType: hydratedExtractType,
    extractProc: hydratedExtractProc,
    extractStream: hydratedExtractStream,
    codegen: hydratedCodegen,
  }
}

export function validateWasmInput(input: unknown, path = "WasmInput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.functionName === undefined || obj.functionName === null) {
    return `${path}.functionName: required field is missing`;
  }
  {
    if (!isWasmFunctionName(obj.functionName)) {
      return `${path}.functionName: invalid enum value '${obj.functionName}' for WasmFunctionName`;
    }
  }
  if (obj.expandTypes !== undefined && obj.expandTypes !== null) {
    {
      const err = validateExpandTypesInput(obj.expandTypes, `${path}.expandTypes`);
      if (err !== null) return err;
    }
  }
  if (obj.extractType !== undefined && obj.extractType !== null) {
    {
      const err = validateExtractTypeInput(obj.extractType, `${path}.extractType`);
      if (err !== null) return err;
    }
  }
  if (obj.extractProc !== undefined && obj.extractProc !== null) {
    {
      const err = validateExtractProcInput(obj.extractProc, `${path}.extractProc`);
      if (err !== null) return err;
    }
  }
  if (obj.extractStream !== undefined && obj.extractStream !== null) {
    {
      const err = validateExtractStreamInput(obj.extractStream, `${path}.extractStream`);
      if (err !== null) return err;
    }
  }
  if (obj.codegen !== undefined && obj.codegen !== null) {
    {
      const err = validateCodegenInput(obj.codegen, `${path}.codegen`);
      if (err !== null) return err;
    }
  }
  return null;
}

/**
 * WasmOutput The output for the WASM function call
 */
export type WasmOutput = {
  expandTypes?: ExpandTypesOutput
  extractType?: ExtractTypeOutput
  extractProc?: ExtractProcOutput
  extractStream?: ExtractStreamOutput
  codegen?: CodegenOutput
}

export function hydrateWasmOutput(input: WasmOutput): WasmOutput {
  const hydratedExpandTypes = input.expandTypes ? hydrateExpandTypesOutput(input.expandTypes) : input.expandTypes
  const hydratedExtractType = input.extractType ? hydrateExtractTypeOutput(input.extractType) : input.extractType
  const hydratedExtractProc = input.extractProc ? hydrateExtractProcOutput(input.extractProc) : input.extractProc
  const hydratedExtractStream = input.extractStream ? hydrateExtractStreamOutput(input.extractStream) : input.extractStream
  const hydratedCodegen = input.codegen ? hydrateCodegenOutput(input.codegen) : input.codegen
  return {
    expandTypes: hydratedExpandTypes,
    extractType: hydratedExtractType,
    extractProc: hydratedExtractProc,
    extractStream: hydratedExtractStream,
    codegen: hydratedCodegen,
  }
}

export function validateWasmOutput(input: unknown, path = "WasmOutput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.expandTypes !== undefined && obj.expandTypes !== null) {
    {
      const err = validateExpandTypesOutput(obj.expandTypes, `${path}.expandTypes`);
      if (err !== null) return err;
    }
  }
  if (obj.extractType !== undefined && obj.extractType !== null) {
    {
      const err = validateExtractTypeOutput(obj.extractType, `${path}.extractType`);
      if (err !== null) return err;
    }
  }
  if (obj.extractProc !== undefined && obj.extractProc !== null) {
    {
      const err = validateExtractProcOutput(obj.extractProc, `${path}.extractProc`);
      if (err !== null) return err;
    }
  }
  if (obj.extractStream !== undefined && obj.extractStream !== null) {
    {
      const err = validateExtractStreamOutput(obj.extractStream, `${path}.extractStream`);
      if (err !== null) return err;
    }
  }
  if (obj.codegen !== undefined && obj.codegen !== null) {
    {
      const err = validateCodegenOutput(obj.codegen, `${path}.codegen`);
      if (err !== null) return err;
    }
  }
  return null;
}
