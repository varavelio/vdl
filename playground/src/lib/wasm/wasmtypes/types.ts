// Code generated by VDL v0.0.0-dev. DO NOT EDIT.
// If you edit this file, it will be overwritten the next time it is generated.
//
// For more information about VDL, visit https://vdl.varavel.com

/* eslint-disable */
/* tslint:disable */
// biome-ignore-all lint: Generated by VDL

// -----------------------------------------------------------------------------
// Enumerations
// -----------------------------------------------------------------------------

/**
 * The type of a constant value
 */
export type ConstType = "string" | "int" | "float" | "bool";

export const ConstTypeList: ConstType[] = [
  "string",
  "int",
  "float",
  "bool",
];

export function isConstType(value: unknown): value is ConstType {
  return ConstTypeList.includes(value as ConstType);
}

/**
 * The underlying value type of an enum
 */
export type EnumType = "string" | "int";

export const EnumTypeList: EnumType[] = [
  "string",
  "int",
];

export function isEnumType(value: unknown): value is EnumType {
  return EnumTypeList.includes(value as EnumType);
}

/**
 * Field primitive types
 */
export type PrimitiveType = "string" | "int" | "float" | "bool" | "datetime";

export const PrimitiveTypeList: PrimitiveType[] = [
  "string",
  "int",
  "float",
  "bool",
  "datetime",
];

export function isPrimitiveType(value: unknown): value is PrimitiveType {
  return PrimitiveTypeList.includes(value as PrimitiveType);
}

/**
 * Categories for a type
 */
export type TypeKind = "primitive" | "type" | "enum" | "array" | "map" | "object";

export const TypeKindList: TypeKind[] = [
  "primitive",
  "type",
  "enum",
  "array",
  "map",
  "object",
];

export function isTypeKind(value: unknown): value is TypeKind {
  return TypeKindList.includes(value as TypeKind);
}

/**
 * Import extension options for TypeScript target
 */
export type TypescriptTargetImportExtension = "none" | ".js" | ".ts";

export const TypescriptTargetImportExtensionList: TypescriptTargetImportExtension[] = [
  "none",
  ".js",
  ".ts",
];

export function isTypescriptTargetImportExtension(value: unknown): value is TypescriptTargetImportExtension {
  return TypescriptTargetImportExtensionList.includes(value as TypescriptTargetImportExtension);
}

/**
 * Represents a function to be called via WASM
 */
export type WasmFunctionName = "ExpandTypes" | "ExtractType" | "ExtractProc" | "ExtractStream" | "Irgen" | "Codegen";

export const WasmFunctionNameList: WasmFunctionName[] = [
  "ExpandTypes",
  "ExtractType",
  "ExtractProc",
  "ExtractStream",
  "Irgen",
  "Codegen",
];

export function isWasmFunctionName(value: unknown): value is WasmFunctionName {
  return WasmFunctionNameList.includes(value as WasmFunctionName);
}

// -----------------------------------------------------------------------------
// Domain Types
// -----------------------------------------------------------------------------

/**
 * ClientTargetConfig Configuration for generating RPC clients
 */
export type ClientTargetConfig = {
  genClient?: boolean
}

export function hydrateClientTargetConfig(input: ClientTargetConfig): ClientTargetConfig {
  const hydratedGenClient = input.genClient ? input.genClient : input.genClient
  return {
    genClient: hydratedGenClient,
  }
}

export function validateClientTargetConfig(_input: unknown, _path = "ClientTargetConfig"): string | null {
  return null;
}

/**
 * CodegenInput Input for codegen function
 */
export type CodegenInput = {
  vdlSchema: string
  target: TargetConfig
}

export function hydrateCodegenInput(input: CodegenInput): CodegenInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedTarget = hydrateTargetConfig(input.target)
  return {
    vdlSchema: hydratedVdlSchema,
    target: hydratedTarget,
  }
}

export function validateCodegenInput(input: unknown, path = "CodegenInput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.target === undefined || obj.target === null) {
    return `${path}.target: required field is missing`;
  }
  {
    const err = validateTargetConfig(obj.target, `${path}.target`);
    if (err !== null) return err;
  }
  return null;
}

/**
 * CodegenOutput Output for codegen function
 */
export type CodegenOutput = {
  files: CodegenOutputFile[]
}

export function hydrateCodegenOutput(input: CodegenOutput): CodegenOutput {
  const hydratedFiles = input.files.map(el => hydrateCodegenOutputFile(el))
  return {
    files: hydratedFiles,
  }
}

export function validateCodegenOutput(input: unknown, path = "CodegenOutput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.files === undefined || obj.files === null) {
    return `${path}.files: required field is missing`;
  }
  {
    if (!Array.isArray(obj.files)) {
      return `${path}.files: expected array, got ${typeof obj.files}`;
    }
    for (let i = 0; i < obj.files.length; i++) {
      {
        const err = validateCodegenOutputFile(obj.files[i], `${path}.files[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * CodegenOutputFile Rrepresents a file generated by codegen function
 */
export type CodegenOutputFile = {
  path: string
  content: string
}

export function hydrateCodegenOutputFile(input: CodegenOutputFile): CodegenOutputFile {
  const hydratedPath = input.path
  const hydratedContent = input.content
  return {
    path: hydratedPath,
    content: hydratedContent,
  }
}

export function validateCodegenOutputFile(_input: unknown, _path = "CodegenOutputFile"): string | null {
  return null;
}

/**
 * CommonTargetConfig Common configuration fields shared by all targets
 */
export type CommonTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
}

export function hydrateCommonTargetConfig(input: CommonTargetConfig): CommonTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
  }
}

export function validateCommonTargetConfig(_input: unknown, _path = "CommonTargetConfig"): string | null {
  return null;
}

/**
 * ConstantDef Represents a constant definition
 */
export type ConstantDef = {
  name: string
  doc?: string
  deprecated?: string
  constType: ConstType
  value: string
}

export function hydrateConstantDef(input: ConstantDef): ConstantDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedDeprecated = input.deprecated ? input.deprecated : input.deprecated
  const hydratedConstType = input.constType
  const hydratedValue = input.value
  return {
    name: hydratedName,
    doc: hydratedDoc,
    deprecated: hydratedDeprecated,
    constType: hydratedConstType,
    value: hydratedValue,
  }
}

export function validateConstantDef(input: unknown, path = "ConstantDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.constType === undefined || obj.constType === null) {
    return `${path}.constType: required field is missing`;
  }
  {
    if (!isConstType(obj.constType)) {
      return `${path}.constType: invalid enum value '${obj.constType}' for ConstType`;
    }
  }
  return null;
}

/**
 * ConstsTargetConfig Configuration for generating constants
 */
export type ConstsTargetConfig = {
  genConsts?: boolean
}

export function hydrateConstsTargetConfig(input: ConstsTargetConfig): ConstsTargetConfig {
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  return {
    genConsts: hydratedGenConsts,
  }
}

export function validateConstsTargetConfig(_input: unknown, _path = "ConstsTargetConfig"): string | null {
  return null;
}

/**
 * DartTargetConfig Configuration for Dart code generation
 */
export type DartTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
}

export function hydrateDartTargetConfig(input: DartTargetConfig): DartTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
  }
}

export function validateDartTargetConfig(_input: unknown, _path = "DartTargetConfig"): string | null {
  return null;
}

/**
 * DocDef Represents a standalone documentation block
 */
export type DocDef = {
  rpcName?: string
  content: string
}

export function hydrateDocDef(input: DocDef): DocDef {
  const hydratedRpcName = input.rpcName ? input.rpcName : input.rpcName
  const hydratedContent = input.content
  return {
    rpcName: hydratedRpcName,
    content: hydratedContent,
  }
}

export function validateDocDef(_input: unknown, _path = "DocDef"): string | null {
  return null;
}

/**
 * EnumDef Represents an enum definition
 */
export type EnumDef = {
  name: string
  doc?: string
  deprecated?: string
  enumType: EnumType
  members: EnumDefMember[]
}

export function hydrateEnumDef(input: EnumDef): EnumDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedDeprecated = input.deprecated ? input.deprecated : input.deprecated
  const hydratedEnumType = input.enumType
  const hydratedMembers = input.members.map(el => hydrateEnumDefMember(el))
  return {
    name: hydratedName,
    doc: hydratedDoc,
    deprecated: hydratedDeprecated,
    enumType: hydratedEnumType,
    members: hydratedMembers,
  }
}

export function validateEnumDef(input: unknown, path = "EnumDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.enumType === undefined || obj.enumType === null) {
    return `${path}.enumType: required field is missing`;
  }
  {
    if (!isEnumType(obj.enumType)) {
      return `${path}.enumType: invalid enum value '${obj.enumType}' for EnumType`;
    }
  }
  if (obj.members === undefined || obj.members === null) {
    return `${path}.members: required field is missing`;
  }
  {
    if (!Array.isArray(obj.members)) {
      return `${path}.members: expected array, got ${typeof obj.members}`;
    }
    for (let i = 0; i < obj.members.length; i++) {
      {
        const err = validateEnumDefMember(obj.members[i], `${path}.members[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * EnumDefMember A member of an enum
 */
export type EnumDefMember = {
  name: string
  value: string
}

export function hydrateEnumDefMember(input: EnumDefMember): EnumDefMember {
  const hydratedName = input.name
  const hydratedValue = input.value
  return {
    name: hydratedName,
    value: hydratedValue,
  }
}

export function validateEnumDefMember(_input: unknown, _path = "EnumDefMember"): string | null {
  return null;
}

/**
 * ExpandTypesInput Input for expandTypes function
 */
export type ExpandTypesInput = {
  vdlSchema: string
}

export function hydrateExpandTypesInput(input: ExpandTypesInput): ExpandTypesInput {
  const hydratedVdlSchema = input.vdlSchema
  return {
    vdlSchema: hydratedVdlSchema,
  }
}

export function validateExpandTypesInput(_input: unknown, _path = "ExpandTypesInput"): string | null {
  return null;
}

/**
 * ExpandTypesOutput Output for expandTypes function
 */
export type ExpandTypesOutput = {
  expandedSchema: string
}

export function hydrateExpandTypesOutput(input: ExpandTypesOutput): ExpandTypesOutput {
  const hydratedExpandedSchema = input.expandedSchema
  return {
    expandedSchema: hydratedExpandedSchema,
  }
}

export function validateExpandTypesOutput(_input: unknown, _path = "ExpandTypesOutput"): string | null {
  return null;
}

/**
 * ExtractProcInput Input for extractProc function
 */
export type ExtractProcInput = {
  vdlSchema: string
  rpcName: string
  procName: string
}

export function hydrateExtractProcInput(input: ExtractProcInput): ExtractProcInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedRpcName = input.rpcName
  const hydratedProcName = input.procName
  return {
    vdlSchema: hydratedVdlSchema,
    rpcName: hydratedRpcName,
    procName: hydratedProcName,
  }
}

export function validateExtractProcInput(_input: unknown, _path = "ExtractProcInput"): string | null {
  return null;
}

/**
 * ExtractProcOutput Output for extractProc function
 */
export type ExtractProcOutput = {
  procSchema: string
}

export function hydrateExtractProcOutput(input: ExtractProcOutput): ExtractProcOutput {
  const hydratedProcSchema = input.procSchema
  return {
    procSchema: hydratedProcSchema,
  }
}

export function validateExtractProcOutput(_input: unknown, _path = "ExtractProcOutput"): string | null {
  return null;
}

/**
 * ExtractStreamInput Input for extractStream function
 */
export type ExtractStreamInput = {
  vdlSchema: string
  rpcName: string
  streamName: string
}

export function hydrateExtractStreamInput(input: ExtractStreamInput): ExtractStreamInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedRpcName = input.rpcName
  const hydratedStreamName = input.streamName
  return {
    vdlSchema: hydratedVdlSchema,
    rpcName: hydratedRpcName,
    streamName: hydratedStreamName,
  }
}

export function validateExtractStreamInput(_input: unknown, _path = "ExtractStreamInput"): string | null {
  return null;
}

/**
 * ExtractStreamOutput Output for extractStream function
 */
export type ExtractStreamOutput = {
  streamSchema: string
}

export function hydrateExtractStreamOutput(input: ExtractStreamOutput): ExtractStreamOutput {
  const hydratedStreamSchema = input.streamSchema
  return {
    streamSchema: hydratedStreamSchema,
  }
}

export function validateExtractStreamOutput(_input: unknown, _path = "ExtractStreamOutput"): string | null {
  return null;
}

/**
 * ExtractTypeInput Input for extractType function
 */
export type ExtractTypeInput = {
  vdlSchema: string
  typeName: string
}

export function hydrateExtractTypeInput(input: ExtractTypeInput): ExtractTypeInput {
  const hydratedVdlSchema = input.vdlSchema
  const hydratedTypeName = input.typeName
  return {
    vdlSchema: hydratedVdlSchema,
    typeName: hydratedTypeName,
  }
}

export function validateExtractTypeInput(_input: unknown, _path = "ExtractTypeInput"): string | null {
  return null;
}

/**
 * ExtractTypeOutput Output for extractType function
 */
export type ExtractTypeOutput = {
  typeSchema: string
}

export function hydrateExtractTypeOutput(input: ExtractTypeOutput): ExtractTypeOutput {
  const hydratedTypeSchema = input.typeSchema
  return {
    typeSchema: hydratedTypeSchema,
  }
}

export function validateExtractTypeOutput(_input: unknown, _path = "ExtractTypeOutput"): string | null {
  return null;
}

/**
 * Field Represents a field with its type fully resolved
 */
export type Field = {
  name: string
  doc?: string
  optional: boolean
  typeRef: TypeRef
}

export function hydrateField(input: Field): Field {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedOptional = input.optional
  const hydratedTypeRef = hydrateTypeRef(input.typeRef)
  return {
    name: hydratedName,
    doc: hydratedDoc,
    optional: hydratedOptional,
    typeRef: hydratedTypeRef,
  }
}

export function validateField(input: unknown, path = "Field"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.typeRef === undefined || obj.typeRef === null) {
    return `${path}.typeRef: required field is missing`;
  }
  {
    const err = validateTypeRef(obj.typeRef, `${path}.typeRef`);
    if (err !== null) return err;
  }
  return null;
}

/**
 * GoTargetConfig Configuration for Go code generation
 */
export type GoTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
  genClient?: boolean
  genServer?: boolean
  package: string
}

export function hydrateGoTargetConfig(input: GoTargetConfig): GoTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  const hydratedGenClient = input.genClient ? input.genClient : input.genClient
  const hydratedGenServer = input.genServer ? input.genServer : input.genServer
  const hydratedPackage = input.package
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
    genClient: hydratedGenClient,
    genServer: hydratedGenServer,
    package: hydratedPackage,
  }
}

export function validateGoTargetConfig(_input: unknown, _path = "GoTargetConfig"): string | null {
  return null;
}

/**
 * IrSchema IrSchema represents the root of the VDL Intermediate Representation (IR).
 * 
 * It acts as the canonical, simplified view of the domain model, abstracting away
 * the complexity of parsing, file structures, and syntactic sugar.
 * 
 * This structure is the "Golden Platter" for code generators, plugins, and analysis tools:
 * a flattened, fully resolved, and read-only data structure ready for consumption.
 * 
 * To ensure reproducible builds and consistent outputs across different environments,
 * all collections within the IRSchema are strictly sorted alphabetically.
 * 
 * This is the structure on which code generators and plugins are executed, as it is the
 * purest and simplest form of representation of the entire IDL.
 */
export type IrSchema = {
  constants: ConstantDef[]
  patterns: PatternDef[]
  enums: EnumDef[]
  types: TypeDef[]
  rpcs: RpcDef[]
  procedures: ProcedureDef[]
  streams: StreamDef[]
  docs: DocDef[]
}

export function hydrateIrSchema(input: IrSchema): IrSchema {
  const hydratedConstants = input.constants.map(el => hydrateConstantDef(el))
  const hydratedPatterns = input.patterns.map(el => hydratePatternDef(el))
  const hydratedEnums = input.enums.map(el => hydrateEnumDef(el))
  const hydratedTypes = input.types.map(el => hydrateTypeDef(el))
  const hydratedRpcs = input.rpcs.map(el => hydrateRpcDef(el))
  const hydratedProcedures = input.procedures.map(el => hydrateProcedureDef(el))
  const hydratedStreams = input.streams.map(el => hydrateStreamDef(el))
  const hydratedDocs = input.docs.map(el => hydrateDocDef(el))
  return {
    constants: hydratedConstants,
    patterns: hydratedPatterns,
    enums: hydratedEnums,
    types: hydratedTypes,
    rpcs: hydratedRpcs,
    procedures: hydratedProcedures,
    streams: hydratedStreams,
    docs: hydratedDocs,
  }
}

export function validateIrSchema(input: unknown, path = "IrSchema"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.constants === undefined || obj.constants === null) {
    return `${path}.constants: required field is missing`;
  }
  {
    if (!Array.isArray(obj.constants)) {
      return `${path}.constants: expected array, got ${typeof obj.constants}`;
    }
    for (let i = 0; i < obj.constants.length; i++) {
      {
        const err = validateConstantDef(obj.constants[i], `${path}.constants[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.patterns === undefined || obj.patterns === null) {
    return `${path}.patterns: required field is missing`;
  }
  {
    if (!Array.isArray(obj.patterns)) {
      return `${path}.patterns: expected array, got ${typeof obj.patterns}`;
    }
    for (let i = 0; i < obj.patterns.length; i++) {
      {
        const err = validatePatternDef(obj.patterns[i], `${path}.patterns[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.enums === undefined || obj.enums === null) {
    return `${path}.enums: required field is missing`;
  }
  {
    if (!Array.isArray(obj.enums)) {
      return `${path}.enums: expected array, got ${typeof obj.enums}`;
    }
    for (let i = 0; i < obj.enums.length; i++) {
      {
        const err = validateEnumDef(obj.enums[i], `${path}.enums[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.types === undefined || obj.types === null) {
    return `${path}.types: required field is missing`;
  }
  {
    if (!Array.isArray(obj.types)) {
      return `${path}.types: expected array, got ${typeof obj.types}`;
    }
    for (let i = 0; i < obj.types.length; i++) {
      {
        const err = validateTypeDef(obj.types[i], `${path}.types[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.rpcs === undefined || obj.rpcs === null) {
    return `${path}.rpcs: required field is missing`;
  }
  {
    if (!Array.isArray(obj.rpcs)) {
      return `${path}.rpcs: expected array, got ${typeof obj.rpcs}`;
    }
    for (let i = 0; i < obj.rpcs.length; i++) {
      {
        const err = validateRpcDef(obj.rpcs[i], `${path}.rpcs[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.procedures === undefined || obj.procedures === null) {
    return `${path}.procedures: required field is missing`;
  }
  {
    if (!Array.isArray(obj.procedures)) {
      return `${path}.procedures: expected array, got ${typeof obj.procedures}`;
    }
    for (let i = 0; i < obj.procedures.length; i++) {
      {
        const err = validateProcedureDef(obj.procedures[i], `${path}.procedures[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.streams === undefined || obj.streams === null) {
    return `${path}.streams: required field is missing`;
  }
  {
    if (!Array.isArray(obj.streams)) {
      return `${path}.streams: expected array, got ${typeof obj.streams}`;
    }
    for (let i = 0; i < obj.streams.length; i++) {
      {
        const err = validateStreamDef(obj.streams[i], `${path}.streams[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.docs === undefined || obj.docs === null) {
    return `${path}.docs: required field is missing`;
  }
  {
    if (!Array.isArray(obj.docs)) {
      return `${path}.docs: expected array, got ${typeof obj.docs}`;
    }
    for (let i = 0; i < obj.docs.length; i++) {
      {
        const err = validateDocDef(obj.docs[i], `${path}.docs[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * IrTargetConfig Configuration for IR (Intermediate Representation) JSON generation
 */
export type IrTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  filename?: string
  minify?: boolean
}

export function hydrateIrTargetConfig(input: IrTargetConfig): IrTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedFilename = input.filename ? input.filename : input.filename
  const hydratedMinify = input.minify ? input.minify : input.minify
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    filename: hydratedFilename,
    minify: hydratedMinify,
  }
}

export function validateIrTargetConfig(_input: unknown, _path = "IrTargetConfig"): string | null {
  return null;
}

/**
 * IrgenInput Input for irgen function
 */
export type IrgenInput = {
  vdlSchema: string
}

export function hydrateIrgenInput(input: IrgenInput): IrgenInput {
  const hydratedVdlSchema = input.vdlSchema
  return {
    vdlSchema: hydratedVdlSchema,
  }
}

export function validateIrgenInput(_input: unknown, _path = "IrgenInput"): string | null {
  return null;
}

/**
 * IrgenOutput Output for irgen function
 */
export type IrgenOutput = {
  constants: ConstantDef[]
  patterns: PatternDef[]
  enums: EnumDef[]
  types: TypeDef[]
  rpcs: RpcDef[]
  procedures: ProcedureDef[]
  streams: StreamDef[]
  docs: DocDef[]
}

export function hydrateIrgenOutput(input: IrgenOutput): IrgenOutput {
  const hydratedConstants = input.constants.map(el => hydrateConstantDef(el))
  const hydratedPatterns = input.patterns.map(el => hydratePatternDef(el))
  const hydratedEnums = input.enums.map(el => hydrateEnumDef(el))
  const hydratedTypes = input.types.map(el => hydrateTypeDef(el))
  const hydratedRpcs = input.rpcs.map(el => hydrateRpcDef(el))
  const hydratedProcedures = input.procedures.map(el => hydrateProcedureDef(el))
  const hydratedStreams = input.streams.map(el => hydrateStreamDef(el))
  const hydratedDocs = input.docs.map(el => hydrateDocDef(el))
  return {
    constants: hydratedConstants,
    patterns: hydratedPatterns,
    enums: hydratedEnums,
    types: hydratedTypes,
    rpcs: hydratedRpcs,
    procedures: hydratedProcedures,
    streams: hydratedStreams,
    docs: hydratedDocs,
  }
}

export function validateIrgenOutput(input: unknown, path = "IrgenOutput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.constants === undefined || obj.constants === null) {
    return `${path}.constants: required field is missing`;
  }
  {
    if (!Array.isArray(obj.constants)) {
      return `${path}.constants: expected array, got ${typeof obj.constants}`;
    }
    for (let i = 0; i < obj.constants.length; i++) {
      {
        const err = validateConstantDef(obj.constants[i], `${path}.constants[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.patterns === undefined || obj.patterns === null) {
    return `${path}.patterns: required field is missing`;
  }
  {
    if (!Array.isArray(obj.patterns)) {
      return `${path}.patterns: expected array, got ${typeof obj.patterns}`;
    }
    for (let i = 0; i < obj.patterns.length; i++) {
      {
        const err = validatePatternDef(obj.patterns[i], `${path}.patterns[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.enums === undefined || obj.enums === null) {
    return `${path}.enums: required field is missing`;
  }
  {
    if (!Array.isArray(obj.enums)) {
      return `${path}.enums: expected array, got ${typeof obj.enums}`;
    }
    for (let i = 0; i < obj.enums.length; i++) {
      {
        const err = validateEnumDef(obj.enums[i], `${path}.enums[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.types === undefined || obj.types === null) {
    return `${path}.types: required field is missing`;
  }
  {
    if (!Array.isArray(obj.types)) {
      return `${path}.types: expected array, got ${typeof obj.types}`;
    }
    for (let i = 0; i < obj.types.length; i++) {
      {
        const err = validateTypeDef(obj.types[i], `${path}.types[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.rpcs === undefined || obj.rpcs === null) {
    return `${path}.rpcs: required field is missing`;
  }
  {
    if (!Array.isArray(obj.rpcs)) {
      return `${path}.rpcs: expected array, got ${typeof obj.rpcs}`;
    }
    for (let i = 0; i < obj.rpcs.length; i++) {
      {
        const err = validateRpcDef(obj.rpcs[i], `${path}.rpcs[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.procedures === undefined || obj.procedures === null) {
    return `${path}.procedures: required field is missing`;
  }
  {
    if (!Array.isArray(obj.procedures)) {
      return `${path}.procedures: expected array, got ${typeof obj.procedures}`;
    }
    for (let i = 0; i < obj.procedures.length; i++) {
      {
        const err = validateProcedureDef(obj.procedures[i], `${path}.procedures[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.streams === undefined || obj.streams === null) {
    return `${path}.streams: required field is missing`;
  }
  {
    if (!Array.isArray(obj.streams)) {
      return `${path}.streams: expected array, got ${typeof obj.streams}`;
    }
    for (let i = 0; i < obj.streams.length; i++) {
      {
        const err = validateStreamDef(obj.streams[i], `${path}.streams[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.docs === undefined || obj.docs === null) {
    return `${path}.docs: required field is missing`;
  }
  {
    if (!Array.isArray(obj.docs)) {
      return `${path}.docs: expected array, got ${typeof obj.docs}`;
    }
    for (let i = 0; i < obj.docs.length; i++) {
      {
        const err = validateDocDef(obj.docs[i], `${path}.docs[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * JsonSchemaTargetConfig Configuration for JSON Schema generation
 */
export type JsonSchemaTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  id?: string
  filename?: string
  root?: string
}

export function hydrateJsonSchemaTargetConfig(input: JsonSchemaTargetConfig): JsonSchemaTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedId = input.id ? input.id : input.id
  const hydratedFilename = input.filename ? input.filename : input.filename
  const hydratedRoot = input.root ? input.root : input.root
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    id: hydratedId,
    filename: hydratedFilename,
    root: hydratedRoot,
  }
}

export function validateJsonSchemaTargetConfig(_input: unknown, _path = "JsonSchemaTargetConfig"): string | null {
  return null;
}

/**
 * OpenApiTargetConfig Configuration for OpenAPI specification generation
 */
export type OpenApiTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  filename?: string
  title: string
  version: string
  description?: string
  baseUrl?: string
  contactName?: string
  contactEmail?: string
  licenseName?: string
}

export function hydrateOpenApiTargetConfig(input: OpenApiTargetConfig): OpenApiTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedFilename = input.filename ? input.filename : input.filename
  const hydratedTitle = input.title
  const hydratedVersion = input.version
  const hydratedDescription = input.description ? input.description : input.description
  const hydratedBaseUrl = input.baseUrl ? input.baseUrl : input.baseUrl
  const hydratedContactName = input.contactName ? input.contactName : input.contactName
  const hydratedContactEmail = input.contactEmail ? input.contactEmail : input.contactEmail
  const hydratedLicenseName = input.licenseName ? input.licenseName : input.licenseName
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    filename: hydratedFilename,
    title: hydratedTitle,
    version: hydratedVersion,
    description: hydratedDescription,
    baseUrl: hydratedBaseUrl,
    contactName: hydratedContactName,
    contactEmail: hydratedContactEmail,
    licenseName: hydratedLicenseName,
  }
}

export function validateOpenApiTargetConfig(_input: unknown, _path = "OpenApiTargetConfig"): string | null {
  return null;
}

/**
 * PatternDef Represents a pattern template for generating dynamic strings
 */
export type PatternDef = {
  name: string
  doc?: string
  deprecated?: string
  template: string
  placeholders: string[]
}

export function hydratePatternDef(input: PatternDef): PatternDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedDeprecated = input.deprecated ? input.deprecated : input.deprecated
  const hydratedTemplate = input.template
  const hydratedPlaceholders = input.placeholders
  return {
    name: hydratedName,
    doc: hydratedDoc,
    deprecated: hydratedDeprecated,
    template: hydratedTemplate,
    placeholders: hydratedPlaceholders,
  }
}

export function validatePatternDef(_input: unknown, _path = "PatternDef"): string | null {
  return null;
}

/**
 * PatternsTargetConfig Configuration for generating patterns
 */
export type PatternsTargetConfig = {
  genPatterns?: boolean
}

export function hydratePatternsTargetConfig(input: PatternsTargetConfig): PatternsTargetConfig {
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  return {
    genPatterns: hydratedGenPatterns,
  }
}

export function validatePatternsTargetConfig(_input: unknown, _path = "PatternsTargetConfig"): string | null {
  return null;
}

/**
 * PlaygroundTargetConfig Configuration for API playground generation
 */
export type PlaygroundTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  defaultBaseUrl?: string
  defaultHeaders?: Record<string, string>
}

export function hydratePlaygroundTargetConfig(input: PlaygroundTargetConfig): PlaygroundTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedDefaultBaseUrl = input.defaultBaseUrl ? input.defaultBaseUrl : input.defaultBaseUrl
  const hydratedDefaultHeaders = input.defaultHeaders ? input.defaultHeaders : input.defaultHeaders
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    defaultBaseUrl: hydratedDefaultBaseUrl,
    defaultHeaders: hydratedDefaultHeaders,
  }
}

export function validatePlaygroundTargetConfig(_input: unknown, _path = "PlaygroundTargetConfig"): string | null {
  return null;
}

/**
 * PluginTargetConfig Configuration for external plugin generators
 */
export type PluginTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  command: string[]
  options?: Record<string, string>
}

export function hydratePluginTargetConfig(input: PluginTargetConfig): PluginTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedCommand = input.command
  const hydratedOptions = input.options ? input.options : input.options
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    command: hydratedCommand,
    options: hydratedOptions,
  }
}

export function validatePluginTargetConfig(_input: unknown, _path = "PluginTargetConfig"): string | null {
  return null;
}

/**
 * ProcedureDef Represents an RPC procedure
 */
export type ProcedureDef = {
  rpcName: string
  name: string
  doc?: string
  deprecated?: string
  input: Field[]
  output: Field[]
}

export function hydrateProcedureDef(input: ProcedureDef): ProcedureDef {
  const hydratedRpcName = input.rpcName
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedDeprecated = input.deprecated ? input.deprecated : input.deprecated
  const hydratedInput = input.input.map(el => hydrateField(el))
  const hydratedOutput = input.output.map(el => hydrateField(el))
  return {
    rpcName: hydratedRpcName,
    name: hydratedName,
    doc: hydratedDoc,
    deprecated: hydratedDeprecated,
    input: hydratedInput,
    output: hydratedOutput,
  }
}

export function validateProcedureDef(input: unknown, path = "ProcedureDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.input === undefined || obj.input === null) {
    return `${path}.input: required field is missing`;
  }
  {
    if (!Array.isArray(obj.input)) {
      return `${path}.input: expected array, got ${typeof obj.input}`;
    }
    for (let i = 0; i < obj.input.length; i++) {
      {
        const err = validateField(obj.input[i], `${path}.input[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.output === undefined || obj.output === null) {
    return `${path}.output: required field is missing`;
  }
  {
    if (!Array.isArray(obj.output)) {
      return `${path}.output: expected array, got ${typeof obj.output}`;
    }
    for (let i = 0; i < obj.output.length; i++) {
      {
        const err = validateField(obj.output[i], `${path}.output[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * PythonTargetConfig Configuration for Python code generation
 */
export type PythonTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
}

export function hydratePythonTargetConfig(input: PythonTargetConfig): PythonTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
  }
}

export function validatePythonTargetConfig(_input: unknown, _path = "PythonTargetConfig"): string | null {
  return null;
}

/**
 * RpcDef Represents an RPC definition
 */
export type RpcDef = {
  name: string
  doc?: string
  deprecated?: string
}

export function hydrateRpcDef(input: RpcDef): RpcDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedDeprecated = input.deprecated ? input.deprecated : input.deprecated
  return {
    name: hydratedName,
    doc: hydratedDoc,
    deprecated: hydratedDeprecated,
  }
}

export function validateRpcDef(_input: unknown, _path = "RpcDef"): string | null {
  return null;
}

/**
 * ServerTargetConfig Configuration for generating RPC servers
 */
export type ServerTargetConfig = {
  genServer?: boolean
}

export function hydrateServerTargetConfig(input: ServerTargetConfig): ServerTargetConfig {
  const hydratedGenServer = input.genServer ? input.genServer : input.genServer
  return {
    genServer: hydratedGenServer,
  }
}

export function validateServerTargetConfig(_input: unknown, _path = "ServerTargetConfig"): string | null {
  return null;
}

/**
 * StreamDef Represents an RPC stream
 */
export type StreamDef = {
  rpcName: string
  name: string
  doc?: string
  deprecated?: string
  input: Field[]
  output: Field[]
}

export function hydrateStreamDef(input: StreamDef): StreamDef {
  const hydratedRpcName = input.rpcName
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedDeprecated = input.deprecated ? input.deprecated : input.deprecated
  const hydratedInput = input.input.map(el => hydrateField(el))
  const hydratedOutput = input.output.map(el => hydrateField(el))
  return {
    rpcName: hydratedRpcName,
    name: hydratedName,
    doc: hydratedDoc,
    deprecated: hydratedDeprecated,
    input: hydratedInput,
    output: hydratedOutput,
  }
}

export function validateStreamDef(input: unknown, path = "StreamDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.input === undefined || obj.input === null) {
    return `${path}.input: required field is missing`;
  }
  {
    if (!Array.isArray(obj.input)) {
      return `${path}.input: expected array, got ${typeof obj.input}`;
    }
    for (let i = 0; i < obj.input.length; i++) {
      {
        const err = validateField(obj.input[i], `${path}.input[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  if (obj.output === undefined || obj.output === null) {
    return `${path}.output: required field is missing`;
  }
  {
    if (!Array.isArray(obj.output)) {
      return `${path}.output: expected array, got ${typeof obj.output}`;
    }
    for (let i = 0; i < obj.output.length; i++) {
      {
        const err = validateField(obj.output[i], `${path}.output[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * TargetConfig Configuration for a specific generation target, only one target type should be set per entry
 */
export type TargetConfig = {
  go?: GoTargetConfig
  typescript?: TypeScriptTargetConfig
  dart?: DartTargetConfig
  python?: PythonTargetConfig
  jsonschema?: JsonSchemaTargetConfig
  openapi?: OpenApiTargetConfig
  playground?: PlaygroundTargetConfig
  plugin?: PluginTargetConfig
  ir?: IrTargetConfig
  vdl?: VdlTargetConfig
}

export function hydrateTargetConfig(input: TargetConfig): TargetConfig {
  const hydratedGo = input.go ? hydrateGoTargetConfig(input.go) : input.go
  const hydratedTypescript = input.typescript ? hydrateTypeScriptTargetConfig(input.typescript) : input.typescript
  const hydratedDart = input.dart ? hydrateDartTargetConfig(input.dart) : input.dart
  const hydratedPython = input.python ? hydratePythonTargetConfig(input.python) : input.python
  const hydratedJsonschema = input.jsonschema ? hydrateJsonSchemaTargetConfig(input.jsonschema) : input.jsonschema
  const hydratedOpenapi = input.openapi ? hydrateOpenApiTargetConfig(input.openapi) : input.openapi
  const hydratedPlayground = input.playground ? hydratePlaygroundTargetConfig(input.playground) : input.playground
  const hydratedPlugin = input.plugin ? hydratePluginTargetConfig(input.plugin) : input.plugin
  const hydratedIr = input.ir ? hydrateIrTargetConfig(input.ir) : input.ir
  const hydratedVdl = input.vdl ? hydrateVdlTargetConfig(input.vdl) : input.vdl
  return {
    go: hydratedGo,
    typescript: hydratedTypescript,
    dart: hydratedDart,
    python: hydratedPython,
    jsonschema: hydratedJsonschema,
    openapi: hydratedOpenapi,
    playground: hydratedPlayground,
    plugin: hydratedPlugin,
    ir: hydratedIr,
    vdl: hydratedVdl,
  }
}

export function validateTargetConfig(input: unknown, path = "TargetConfig"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.go !== undefined && obj.go !== null) {
    {
      const err = validateGoTargetConfig(obj.go, `${path}.go`);
      if (err !== null) return err;
    }
  }
  if (obj.typescript !== undefined && obj.typescript !== null) {
    {
      const err = validateTypeScriptTargetConfig(obj.typescript, `${path}.typescript`);
      if (err !== null) return err;
    }
  }
  if (obj.dart !== undefined && obj.dart !== null) {
    {
      const err = validateDartTargetConfig(obj.dart, `${path}.dart`);
      if (err !== null) return err;
    }
  }
  if (obj.python !== undefined && obj.python !== null) {
    {
      const err = validatePythonTargetConfig(obj.python, `${path}.python`);
      if (err !== null) return err;
    }
  }
  if (obj.jsonschema !== undefined && obj.jsonschema !== null) {
    {
      const err = validateJsonSchemaTargetConfig(obj.jsonschema, `${path}.jsonschema`);
      if (err !== null) return err;
    }
  }
  if (obj.openapi !== undefined && obj.openapi !== null) {
    {
      const err = validateOpenApiTargetConfig(obj.openapi, `${path}.openapi`);
      if (err !== null) return err;
    }
  }
  if (obj.playground !== undefined && obj.playground !== null) {
    {
      const err = validatePlaygroundTargetConfig(obj.playground, `${path}.playground`);
      if (err !== null) return err;
    }
  }
  if (obj.plugin !== undefined && obj.plugin !== null) {
    {
      const err = validatePluginTargetConfig(obj.plugin, `${path}.plugin`);
      if (err !== null) return err;
    }
  }
  if (obj.ir !== undefined && obj.ir !== null) {
    {
      const err = validateIrTargetConfig(obj.ir, `${path}.ir`);
      if (err !== null) return err;
    }
  }
  if (obj.vdl !== undefined && obj.vdl !== null) {
    {
      const err = validateVdlTargetConfig(obj.vdl, `${path}.vdl`);
      if (err !== null) return err;
    }
  }
  return null;
}

/**
 * TypeDef Represents a type definition
 */
export type TypeDef = {
  name: string
  doc?: string
  deprecated?: string
  fields: Field[]
}

export function hydrateTypeDef(input: TypeDef): TypeDef {
  const hydratedName = input.name
  const hydratedDoc = input.doc ? input.doc : input.doc
  const hydratedDeprecated = input.deprecated ? input.deprecated : input.deprecated
  const hydratedFields = input.fields.map(el => hydrateField(el))
  return {
    name: hydratedName,
    doc: hydratedDoc,
    deprecated: hydratedDeprecated,
    fields: hydratedFields,
  }
}

export function validateTypeDef(input: unknown, path = "TypeDef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.fields === undefined || obj.fields === null) {
    return `${path}.fields: required field is missing`;
  }
  {
    if (!Array.isArray(obj.fields)) {
      return `${path}.fields: expected array, got ${typeof obj.fields}`;
    }
    for (let i = 0; i < obj.fields.length; i++) {
      {
        const err = validateField(obj.fields[i], `${path}.fields[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * TypeRef Represents any referenced type in a unified way
 */
export type TypeRef = {
  kind: TypeKind
  primitiveName?: PrimitiveType
  typeName?: string
  enumName?: string
  enumType?: EnumType
  arrayType?: TypeRef
  arrayDims?: number
  mapType?: TypeRef
  objectFields?: Field[]
}

export function hydrateTypeRef(input: TypeRef): TypeRef {
  const hydratedKind = input.kind
  const hydratedPrimitiveName = input.primitiveName ? input.primitiveName : input.primitiveName
  const hydratedTypeName = input.typeName ? input.typeName : input.typeName
  const hydratedEnumName = input.enumName ? input.enumName : input.enumName
  const hydratedEnumType = input.enumType ? input.enumType : input.enumType
  const hydratedArrayType = input.arrayType ? hydrateTypeRef(input.arrayType) : input.arrayType
  const hydratedArrayDims = input.arrayDims ? input.arrayDims : input.arrayDims
  const hydratedMapType = input.mapType ? hydrateTypeRef(input.mapType) : input.mapType
  const hydratedObjectFields = input.objectFields ? input.objectFields.map(el => hydrateField(el)) : input.objectFields
  return {
    kind: hydratedKind,
    primitiveName: hydratedPrimitiveName,
    typeName: hydratedTypeName,
    enumName: hydratedEnumName,
    enumType: hydratedEnumType,
    arrayType: hydratedArrayType,
    arrayDims: hydratedArrayDims,
    mapType: hydratedMapType,
    objectFields: hydratedObjectFields,
  }
}

export function validateTypeRef(input: unknown, path = "TypeRef"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.kind === undefined || obj.kind === null) {
    return `${path}.kind: required field is missing`;
  }
  {
    if (!isTypeKind(obj.kind)) {
      return `${path}.kind: invalid enum value '${obj.kind}' for TypeKind`;
    }
  }
  if (obj.primitiveName !== undefined && obj.primitiveName !== null) {
    {
      if (!isPrimitiveType(obj.primitiveName)) {
        return `${path}.primitiveName: invalid enum value '${obj.primitiveName}' for PrimitiveType`;
      }
    }
  }
  if (obj.enumType !== undefined && obj.enumType !== null) {
    {
      if (!isEnumType(obj.enumType)) {
        return `${path}.enumType: invalid enum value '${obj.enumType}' for EnumType`;
      }
    }
  }
  if (obj.arrayType !== undefined && obj.arrayType !== null) {
    {
      const err = validateTypeRef(obj.arrayType, `${path}.arrayType`);
      if (err !== null) return err;
    }
  }
  if (obj.mapType !== undefined && obj.mapType !== null) {
    {
      const err = validateTypeRef(obj.mapType, `${path}.mapType`);
      if (err !== null) return err;
    }
  }
  if (obj.objectFields !== undefined && obj.objectFields !== null) {
    {
      if (!Array.isArray(obj.objectFields)) {
        return `${path}.objectFields: expected array, got ${typeof obj.objectFields}`;
      }
      for (let i = 0; i < obj.objectFields.length; i++) {
        {
          const err = validateField(obj.objectFields[i], `${path}.objectFields[${i}]`);
          if (err !== null) return err;
        }
      }
    }
  }
  return null;
}

/**
 * TypeScriptTargetConfig Configuration for TypeScript code generation
 */
export type TypeScriptTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  genPatterns?: boolean
  genConsts?: boolean
  genClient?: boolean
  genServer?: boolean
  importExtension?: TypescriptTargetImportExtension
}

export function hydrateTypeScriptTargetConfig(input: TypeScriptTargetConfig): TypeScriptTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedGenPatterns = input.genPatterns ? input.genPatterns : input.genPatterns
  const hydratedGenConsts = input.genConsts ? input.genConsts : input.genConsts
  const hydratedGenClient = input.genClient ? input.genClient : input.genClient
  const hydratedGenServer = input.genServer ? input.genServer : input.genServer
  const hydratedImportExtension = input.importExtension ? input.importExtension : input.importExtension
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    genPatterns: hydratedGenPatterns,
    genConsts: hydratedGenConsts,
    genClient: hydratedGenClient,
    genServer: hydratedGenServer,
    importExtension: hydratedImportExtension,
  }
}

export function validateTypeScriptTargetConfig(input: unknown, path = "TypeScriptTargetConfig"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.importExtension !== undefined && obj.importExtension !== null) {
    {
      if (!isTypescriptTargetImportExtension(obj.importExtension)) {
        return `${path}.importExtension: invalid enum value '${obj.importExtension}' for TypescriptTargetImportExtension`;
      }
    }
  }
  return null;
}

/**
 * VdlCodegenConfig VDL Configuration Schema
 * 
 * This schema defines the configuration format for the VDL code generator (vdl.yaml)
 * 
 * It supports multiple target languages and output formats
 */
export type VdlCodegenConfig = {
  version: number
  schema?: string
  targets: TargetConfig[]
}

export function hydrateVdlCodegenConfig(input: VdlCodegenConfig): VdlCodegenConfig {
  const hydratedVersion = input.version
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedTargets = input.targets.map(el => hydrateTargetConfig(el))
  return {
    version: hydratedVersion,
    schema: hydratedSchema,
    targets: hydratedTargets,
  }
}

export function validateVdlCodegenConfig(input: unknown, path = "VdlCodegenConfig"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.targets === undefined || obj.targets === null) {
    return `${path}.targets: required field is missing`;
  }
  {
    if (!Array.isArray(obj.targets)) {
      return `${path}.targets: expected array, got ${typeof obj.targets}`;
    }
    for (let i = 0; i < obj.targets.length; i++) {
      {
        const err = validateTargetConfig(obj.targets[i], `${path}.targets[${i}]`);
        if (err !== null) return err;
      }
    }
  }
  return null;
}

/**
 * VdlTargetConfig Configuration for unified VDL schema generation (merges all includes and external docs)
 */
export type VdlTargetConfig = {
  output: string
  clean?: boolean
  schema?: string
  filename?: string
}

export function hydrateVdlTargetConfig(input: VdlTargetConfig): VdlTargetConfig {
  const hydratedOutput = input.output
  const hydratedClean = input.clean ? input.clean : input.clean
  const hydratedSchema = input.schema ? input.schema : input.schema
  const hydratedFilename = input.filename ? input.filename : input.filename
  return {
    output: hydratedOutput,
    clean: hydratedClean,
    schema: hydratedSchema,
    filename: hydratedFilename,
  }
}

export function validateVdlTargetConfig(_input: unknown, _path = "VdlTargetConfig"): string | null {
  return null;
}

/**
 * WasmInput The input for the WASM function call
 */
export type WasmInput = {
  functionName: WasmFunctionName
  expandTypes?: ExpandTypesInput
  extractType?: ExtractTypeInput
  extractProc?: ExtractProcInput
  extractStream?: ExtractStreamInput
  irgen?: IrgenInput
  codegen?: CodegenInput
}

export function hydrateWasmInput(input: WasmInput): WasmInput {
  const hydratedFunctionName = input.functionName
  const hydratedExpandTypes = input.expandTypes ? hydrateExpandTypesInput(input.expandTypes) : input.expandTypes
  const hydratedExtractType = input.extractType ? hydrateExtractTypeInput(input.extractType) : input.extractType
  const hydratedExtractProc = input.extractProc ? hydrateExtractProcInput(input.extractProc) : input.extractProc
  const hydratedExtractStream = input.extractStream ? hydrateExtractStreamInput(input.extractStream) : input.extractStream
  const hydratedIrgen = input.irgen ? hydrateIrgenInput(input.irgen) : input.irgen
  const hydratedCodegen = input.codegen ? hydrateCodegenInput(input.codegen) : input.codegen
  return {
    functionName: hydratedFunctionName,
    expandTypes: hydratedExpandTypes,
    extractType: hydratedExtractType,
    extractProc: hydratedExtractProc,
    extractStream: hydratedExtractStream,
    irgen: hydratedIrgen,
    codegen: hydratedCodegen,
  }
}

export function validateWasmInput(input: unknown, path = "WasmInput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.functionName === undefined || obj.functionName === null) {
    return `${path}.functionName: required field is missing`;
  }
  {
    if (!isWasmFunctionName(obj.functionName)) {
      return `${path}.functionName: invalid enum value '${obj.functionName}' for WasmFunctionName`;
    }
  }
  if (obj.expandTypes !== undefined && obj.expandTypes !== null) {
    {
      const err = validateExpandTypesInput(obj.expandTypes, `${path}.expandTypes`);
      if (err !== null) return err;
    }
  }
  if (obj.extractType !== undefined && obj.extractType !== null) {
    {
      const err = validateExtractTypeInput(obj.extractType, `${path}.extractType`);
      if (err !== null) return err;
    }
  }
  if (obj.extractProc !== undefined && obj.extractProc !== null) {
    {
      const err = validateExtractProcInput(obj.extractProc, `${path}.extractProc`);
      if (err !== null) return err;
    }
  }
  if (obj.extractStream !== undefined && obj.extractStream !== null) {
    {
      const err = validateExtractStreamInput(obj.extractStream, `${path}.extractStream`);
      if (err !== null) return err;
    }
  }
  if (obj.irgen !== undefined && obj.irgen !== null) {
    {
      const err = validateIrgenInput(obj.irgen, `${path}.irgen`);
      if (err !== null) return err;
    }
  }
  if (obj.codegen !== undefined && obj.codegen !== null) {
    {
      const err = validateCodegenInput(obj.codegen, `${path}.codegen`);
      if (err !== null) return err;
    }
  }
  return null;
}

/**
 * WasmOutput The output for the WASM function call
 */
export type WasmOutput = {
  expandTypes?: ExpandTypesOutput
  extractType?: ExtractTypeOutput
  extractProc?: ExtractProcOutput
  extractStream?: ExtractStreamOutput
  irgen?: IrgenOutput
  codegen?: CodegenOutput
}

export function hydrateWasmOutput(input: WasmOutput): WasmOutput {
  const hydratedExpandTypes = input.expandTypes ? hydrateExpandTypesOutput(input.expandTypes) : input.expandTypes
  const hydratedExtractType = input.extractType ? hydrateExtractTypeOutput(input.extractType) : input.extractType
  const hydratedExtractProc = input.extractProc ? hydrateExtractProcOutput(input.extractProc) : input.extractProc
  const hydratedExtractStream = input.extractStream ? hydrateExtractStreamOutput(input.extractStream) : input.extractStream
  const hydratedIrgen = input.irgen ? hydrateIrgenOutput(input.irgen) : input.irgen
  const hydratedCodegen = input.codegen ? hydrateCodegenOutput(input.codegen) : input.codegen
  return {
    expandTypes: hydratedExpandTypes,
    extractType: hydratedExtractType,
    extractProc: hydratedExtractProc,
    extractStream: hydratedExtractStream,
    irgen: hydratedIrgen,
    codegen: hydratedCodegen,
  }
}

export function validateWasmOutput(input: unknown, path = "WasmOutput"): string | null {
  if (input === null || input === undefined || typeof input !== "object") {
    return `${path}: expected object, got ${typeof input}`;
  }
  const obj = input as Record<string, unknown>;

  if (obj.expandTypes !== undefined && obj.expandTypes !== null) {
    {
      const err = validateExpandTypesOutput(obj.expandTypes, `${path}.expandTypes`);
      if (err !== null) return err;
    }
  }
  if (obj.extractType !== undefined && obj.extractType !== null) {
    {
      const err = validateExtractTypeOutput(obj.extractType, `${path}.extractType`);
      if (err !== null) return err;
    }
  }
  if (obj.extractProc !== undefined && obj.extractProc !== null) {
    {
      const err = validateExtractProcOutput(obj.extractProc, `${path}.extractProc`);
      if (err !== null) return err;
    }
  }
  if (obj.extractStream !== undefined && obj.extractStream !== null) {
    {
      const err = validateExtractStreamOutput(obj.extractStream, `${path}.extractStream`);
      if (err !== null) return err;
    }
  }
  if (obj.irgen !== undefined && obj.irgen !== null) {
    {
      const err = validateIrgenOutput(obj.irgen, `${path}.irgen`);
      if (err !== null) return err;
    }
  }
  if (obj.codegen !== undefined && obj.codegen !== null) {
    {
      const err = validateCodegenOutput(obj.codegen, `${path}.codegen`);
      if (err !== null) return err;
    }
  }
  return null;
}
