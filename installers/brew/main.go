package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"

	"github.com/varavelio/gen"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "error executing program: %s\n", err.Error())
		os.Exit(1)
	}
}

// Run generates the vdl.rb homebrew formula and returns it as a string and an
// error if something went wrong
func run() error {
	if len(os.Args) != 2 {
		return fmt.Errorf("usage: go run main.go vx.x.x")
	}
	version := strings.TrimPrefix(strings.TrimSpace(strings.ToLower(os.Args[1])), "v")

	baseURL := "https://github.com/varavelio/vdl/releases/download/v" + version
	checksumsURL := baseURL + "/checksums.txt"
	darwinArm64URL := baseURL + "/vdl_darwin_arm64.tar.gz"
	darwinAmd64URL := baseURL + "/vdl_darwin_amd64.tar.gz"
	linuxArm64URL := baseURL + "/vdl_linux_arm64.tar.gz"
	linuxAmd64URL := baseURL + "/vdl_linux_amd64.tar.gz"

	hashes, err := getHashes(checksumsURL)
	if err != nil {
		return fmt.Errorf("error getting checksum hashes: %w", err)
	}
	darwinArm64Hash, _ := hashes["vdl_darwin_arm64.tar.gz"]
	darwinAmd64Hash, _ := hashes["vdl_darwin_amd64.tar.gz"]
	linuxArm64Hash, _ := hashes["vdl_linux_arm64.tar.gz"]
	linuxAmd64Hash, _ := hashes["vdl_linux_amd64.tar.gz"]
	if darwinArm64Hash == "" ||
		darwinAmd64Hash == "" ||
		linuxArm64Hash == "" ||
		linuxAmd64Hash == "" {
		return fmt.Errorf("some checksum hash missing from list: %v", hashes)
	}

	fileName := "vdl.rb"
	fileNamePinned := "vdl@" + version + ".rb"
	if strings.Contains(version, "-") {
		fileName = "vdl-next.rb"
	}

	fileContent := generateFile(generateFileInput{
		className:       getClassName(fileName),
		version:         version,
		darwinArm64URL:  darwinArm64URL,
		darwinAmd64URL:  darwinAmd64URL,
		linuxArm64URL:   linuxArm64URL,
		linuxAmd64URL:   linuxAmd64URL,
		darwinArm64Hash: darwinArm64Hash,
		darwinAmd64Hash: darwinAmd64Hash,
		linuxArm64Hash:  linuxArm64Hash,
		linuxAmd64Hash:  linuxAmd64Hash,
	})

	fileContentPinned := generateFile(generateFileInput{
		className:       getClassName(fileNamePinned),
		version:         version,
		darwinArm64URL:  darwinArm64URL,
		darwinAmd64URL:  darwinAmd64URL,
		linuxArm64URL:   linuxArm64URL,
		linuxAmd64URL:   linuxAmd64URL,
		darwinArm64Hash: darwinArm64Hash,
		darwinAmd64Hash: darwinAmd64Hash,
		linuxArm64Hash:  linuxArm64Hash,
		linuxAmd64Hash:  linuxAmd64Hash,
	})

	_ = os.RemoveAll("./Formula")
	_ = os.MkdirAll("./Formula/vdl", 0755)

	if err := os.WriteFile("./Formula/vdl/"+fileName, []byte(fileContent), 0644); err != nil {
		return fmt.Errorf("error writing %s file: %w", fileName, err)
	}
	if err := os.WriteFile("./Formula/vdl/"+fileNamePinned, []byte(fileContentPinned), 0644); err != nil {
		return fmt.Errorf("error writing %s file: %w", fileNamePinned, err)
	}

	return nil
}

type generateFileInput struct {
	className string
	version   string

	darwinArm64URL string
	darwinAmd64URL string
	linuxArm64URL  string
	linuxAmd64URL  string

	darwinArm64Hash string
	darwinAmd64Hash string
	linuxArm64Hash  string
	linuxAmd64Hash  string
}

// generateFile generates a .rb file for the formula with the provided data.
func generateFile(input generateFileInput) string {
	g := gen.New()
	g.Line("# This file was generated by an automatic VDL release script. DO NOT EDIT.")
	g.Linef(`class %s < Formula`, input.className)
	g.Line(`  desc "Open-source cross-language definition engine for modern stacks. Define your data structures, APIs, contracts, and generate type-safe code for your backend and frontend instantly."`)
	g.Line(`  homepage "https://varavel.com/vdl"`)
	g.Line(`  license "MIT"`)
	g.Linef(`  version "%s"`, input.version)
	g.Break()
	g.Line(`  on_macos do`)
	g.Line(`    if Hardware::CPU.arm?`)
	g.Linef(`      url "%s"`, input.darwinArm64URL)
	g.Linef(`      sha256 "%s"`, input.darwinArm64Hash)
	g.Line(`    else`)
	g.Linef(`      url "%s"`, input.darwinAmd64URL)
	g.Linef(`      sha256 "%s"`, input.darwinAmd64Hash)
	g.Line(`    end`)
	g.Line(`  end`)
	g.Break()
	g.Line(`  on_linux do`)
	g.Line(`    if Hardware::CPU.arm? && Hardware::CPU.is_64_bit?`)
	g.Linef(`      url "%s"`, input.linuxArm64URL)
	g.Linef(`      sha256 "%s"`, input.linuxArm64Hash)
	g.Line(`    else`)
	g.Linef(`      url "%s"`, input.linuxAmd64URL)
	g.Linef(`      sha256 "%s"`, input.linuxAmd64Hash)
	g.Line(`    end`)
	g.Line(`  end`)
	g.Break()
	g.Line(`  def install`)
	g.Line(`    bin.install "vdl"`)
	g.Line(`  end`)
	g.Break()
	g.Line(`  test do`)
	g.Line(`    system "#{bin}/vdl", "version"`)
	g.Line(`  end`)
	g.Line(`end`)
	g.Break()
	return g.String()
}

// getHashes downloads the hashes file from the release and returns a fileName -> hash map.
func getHashes(url string) (map[string]string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("error downloading checksums file from %s: %w", url, err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode >= 400 {
		return nil, fmt.Errorf("status %s downloading checksums file from %s", resp.Status, url)
	}

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading checksums file: %w", err)
	}

	checksums := map[string]string{}
	files := strings.SplitSeq(strings.TrimSpace(string(bytes)), "\n")
	for file := range files {
		file = strings.TrimSpace(file)
		if file == "" {
			continue
		}
		parts := strings.Split(file, "  ")
		if len(parts) != 2 {
			return nil, fmt.Errorf("error reading checksum line: bad format: %s", file)
		}

		checksums[parts[1]] = parts[0]
	}

	return checksums, nil
}

// getClassName returns the ruby class name from the file name.
func getClassName(fileName string) string {
	// Remove unwanted characters
	fileName = strings.ReplaceAll(fileName, ".rb", "")
	fileName = strings.ReplaceAll(fileName, "-", " ")
	fileName = strings.ReplaceAll(fileName, ".", " ")
	fileName = strings.ReplaceAll(fileName, "@", " At ")

	// Capitalize
	fileName = strings.Title(fileName)
	fileName = strings.ReplaceAll(fileName, " ", "")

	return fileName
}
