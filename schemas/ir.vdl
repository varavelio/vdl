"""
IrSchema is the generator-facing representation of a VDL program.

This model is intentionally "flat" and "resolved":
- spreads are already expanded
- references are already resolved
- collections are in deterministic order

A code generator should be able to consume IrSchema directly, without needing
to re-run parser or semantic-analysis logic.
"""
type IrSchema {
  """ Constant definitions, sorted by name """
  constants: ConstantDef[]

  """ Enum definitions, sorted by name """
  enums: EnumDef[]

  """ Type definitions, sorted by name """
  types: TypeDef[]

  """ Standalone documentation blocks in source traversal order """
  docs: DocDef[]
}

/********
* ENUMS *
********/

""" Kind discriminator for TypeRef """
enum TypeKind {
  Primitive = "primitive"
  Type = "type"
  Enum = "enum"
  Array = "array"
  Map = "map"
  Object = "object"
}

""" Primitive scalar type names """
enum PrimitiveType {
  String = "string"
  Int = "int"
  Float = "float"
  Bool = "bool"
  Datetime = "datetime"
}

""" Underlying storage kind used by an enum """
enum EnumType {
  String = "string"
  Int = "int"
}

"""
Kind discriminator for Value.

Value is used for fully resolved literal data in:
- constant values
- annotation arguments
"""
enum ValueKind {
  String = "string"
  Int = "int"
  Float = "float"
  Bool = "bool"
  Object = "object"
  Array = "array"
}

/*******************
* TYPE SYSTEM CORE *
*******************/

"""
Normalized type reference used by fields and constants.

`kind` selects which payload fields are meaningful. Generators should inspect
`kind` first, then read the related payload fields.
"""
type TypeRef {
  """ Type category discriminator """
  kind: TypeKind

  """ Primitive type name when `kind` is `primitive` """
  primitiveName?: PrimitiveType

  """ Referenced type name when `kind` is `type` """
  typeName?: string

  """ Referenced enum name when `kind` is `enum` """
  enumName?: string

  """ Referenced enum underlying kind when `kind` is `enum` """
  enumType?: EnumType

  """ Element type when `kind` is `array` """
  arrayType?: TypeRef

  """ Array rank when `kind` is `array` (for example, 2 for `T[][]`) """
  arrayDims?: int

  """ Map value type when `kind` is `map` """
  mapType?: TypeRef

  """ Inline object fields when `kind` is `object` """
  objectFields?: Field[]
}

"""
Annotation metadata preserved in IR.

`name` is the annotation identifier without the `@` prefix.
`argument`, when present, is fully resolved as a Value.
"""
type Annotation {
  """ Annotation name without `@` """
  name: string

  """ Optional resolved argument payload """
  argument?: Value
}

""" Flattened object/type field definition """
type Field {
  """ Field name """
  name: string

  """ Optional field documentation """
  doc?: string

  """ True when the field is optional (`?`) """
  optional: bool

  """ Field annotations in source order """
  annotations: Annotation[]

  """ Normalized field type reference """
  typeRef: TypeRef
}

/*****************
* RESOLVED VALUE *
*****************/

"""
Fully resolved literal value.

The selected payload is determined by `kind`:
- `string` -> `stringValue`
- `int` -> `intValue`
- `float` -> `floatValue`
- `bool` -> `boolValue`
- `object` -> `objectEntries`
- `array` -> `arrayItems`
"""
type Value {
  """ Value category discriminator """
  kind: ValueKind

  """ Payload for `kind = string` """
  stringValue?: string

  """ Payload for `kind = int` """
  intValue?: int

  """ Payload for `kind = float` """
  floatValue?: float

  """ Payload for `kind = bool` """
  boolValue?: bool

  """ Payload for `kind = object` """
  objectEntries?: ObjectEntry[]

  """ Payload for `kind = array` """
  arrayItems?: Value[]
}

""" Key/value pair inside an object Value payload """
type ObjectEntry {
  """ Object key """
  key: string

  """ Fully resolved value for this key """
  value: Value
}

/************************
* TOP LEVEL DEFINITIONS *
************************/

"""
Flattened type definition.

All spreads are already expanded into `fields`.
"""
type TypeDef {
  """ Type name """
  name: string

  """ Optional type documentation """
  doc?: string

  """ Type annotations in source order """
  annotations: Annotation[]

  """ Type fields in source order """
  fields: Field[]
}

"""
Flattened enum definition.

All enum spreads are already expanded into `members`.
"""
type EnumDef {
  """ Enum name """
  name: string

  """ Optional enum documentation """
  doc?: string

  """ Enum annotations in source order """
  annotations: Annotation[]

  """ Enum underlying storage kind """
  enumType: EnumType

  """ Enum members in source order after spread expansion """
  members: EnumDefMember[]
}

""" Enum member definition """
type EnumDefMember {
  """ Member name """
  name: string

  """ Canonical string representation of the member value """
  value: string

  """ Optional member documentation """
  doc?: string

  """ Member annotations in source order """
  annotations: Annotation[]
}

"""
Fully resolved constant definition.

`typeRef` is explicit or inferred by analysis.
`value` contains the fully resolved literal payload.
"""
type ConstantDef {
  """ Constant name """
  name: string

  """ Optional constant documentation """
  doc?: string

  """ Constant annotations in source order """
  annotations: Annotation[]

  """ Normalized constant type reference (explicit or inferred) """
  typeRef: TypeRef

  """ Fully resolved constant value """
  value: Value
}

"""
Standalone documentation block.

Used for top-level docstrings that are not attached to a type/enum/constant.
"""
type DocDef {
  """ Resolved documentation content """
  content: string
}
