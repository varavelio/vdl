---
title: UFO-RPC DSL Specification
description: Full specification of the UFO RPC (URPC) DSL language
---

## Overview

The UFO DSL is a domain-specific language designed to define RPC services, schemas and contracts with strong typing. It provides a declarative syntax for defining data structures and procedures that UFO RPC can interpret and generate code for.

The primary goal of URPC is to offer an intuitive, human-readable format that ensures the best possible developer experience (DX) while maintaining type safety.

This DSL is a source of truth for your projects from which you can generate type safe code for multiple programming languages.

## UFO Syntax

This is the syntax for the DSL.

```ufo
import "./foo.ufo"

// <comment>

/*
  <multiline comment>
*/

""" <Standalone documentation> """

""" <Type documentation> """
type <CustomTypeName> {
  """ <Field documentation> """
  <field>[?]: <Type>
}

""" <Constant documentation> """
const <ConstantName> = <Value>

""" <Enum documentation> """
enum <EnumName>[: <EnumType>] {
  <EnumMember>[ = <EnumValue>]
  <EnumMember>[ = <EnumValue>]
}

""" <Pattern documentation> """
pattern <PatternName> = "<PatternValue>"

""" <RPC documentation> """
rpc <RPCName> {
  """ <RPC Standalone documentation> """

  """ <Procedure documentation> """
  proc <ProcedureName> {
    input {
      """ <Field documentation> """
      <field>[?]: <PrimitiveType> | <CustomType>
    }

    output {
      """ <Field documentation> """
      <field>[?]: <PrimitiveType> | <CustomType>
    }
  }

  """ <Stream documentation> """
  stream <StreamName> {
    input {
      """ <Field documentation> """
      <field>[?]: <PrimitiveType> | <CustomType>
    }

    output {
      """ <Field documentation> """
      <field>[?]: <PrimitiveType> | <CustomType>
    }
  }
}
```

## Imports

To maintain clean and maintainable projects, UFO RPC allows you to split your schemas into multiple files.

This modular approach helps you organize your types and procedures by domain, making them easier to navigate and reuse across different schemas.

### How to use Imports

You can include other `.ufo` files using the `import` keyword, typically at the top of your file.

```ufo
// auth.ufo
type Session {
  token: string
  expiresAt: datetime
}

// main.ufo
import "./auth.ufo"

type AuthInfo {
  session: Session
}
```

### Core Principles

- **Modular Reusability:** When a file is imported, all its definitions (types, enums, constants, etc.) become available in the current file. You can think of it as a copy-paste of the imported file content.
- **Relative Paths:** Imports always use relative paths (e.g., `./common.ufo`) starting from the current file's directory.
- **Automatic De-duplication:** If your project structure leads to the same file being imported multiple times through different paths, UFO RPC ensures it is only processed once, preventing conflicts.
- **Circular Dependency Prevention:** To maintain a clear and predictable structure, the compiler automatically detects and rejects circular imports (e.g., File A importing File B, which in turn imports File A).

This system empowers you to build a robust library of common types while keeping your service-specific logic focused and uncluttered.

## Types

Types are the building blocks of your schema. They define the structure of the data that is sent and received by your procedures and streams or generated by the compiler.

### Primitive Types

Primitive types are the types that are built-in into the URPC DSL.

| DSL        | JSON Type | Description                           |
| ---------- | --------- | ------------------------------------- |
| `string`   | string    | UTF-8 text string                     |
| `int`      | integer   | 64-bit integer                        |
| `float`    | number    | 64-bit floating point number          |
| `bool`     | boolean   | Either true or false                  |
| `datetime` | string    | Date and time value (ISO 8601 format) |

### Composite Types

Composite types are types that are composed of other primitive or custom types. They can be used to create more complex data structures.

#### Arrays

A list of elements of a specific type.

```ufo
// Syntax: ElementType[]
string[]
User[]
```

#### Maps

A dictionary where keys are always strings and values are of a specific type.

```ufo
// Syntax: map<ValueType>
map<int>     // JSON: { "a": 1, "b": 2 }
map<User>    // JSON: { "id1": {...}, "id2": {...} }
```

#### Inline types

An anonymous structure which contains fields with other types.

```ufo
{
  field1: string
  field2: int
}
```

### Custom Types

You can define custom types additional of the primitive types provided by the
transpiler that you can use in the input and output of your procedures and streams.

```ufo
"""
<Type documentation>
"""
type <CustomTypeName> {
  """ <Field documentation> """
  <field>[?]: <Type>
}
```

#### Custom type documentation

You can add documentation to your custom types to help the developer understand
how to use them, they can include Markdown syntax that will be rendered in the
generated documentation.

#### Type composition and destructuration

To reuse fields from other types, you have two options: composition and destructuration.

**Type composition**: Use another type as a field inside your type.

```ufo
type BaseEntity {
  id: string
  createdAt: datetime
  updatedAt: datetime
}

type User {
  base: BaseEntity
  email: string
  name: string
}

// User is equivalent to:
type User {
  base: {
    id: string
    createdAt: datetime
    updatedAt: datetime
  }
  email: string
  name: string
}
```

**Type destructuration**: Include the fields of another type directly into your type.

```ufo
type BaseEntity {
  id: string
  createdAt: datetime
  updatedAt: datetime
}

type User {
  ...BaseEntity
  email: string
  name: string
}

// User is equivalent to:
type User {
  id: string
  createdAt: datetime
  updatedAt: datetime
  email: string
  name: string
}
```

#### Optional fields

All fields of a type are required by default. To make a field optional, use the `?` suffix. The generated code includes the necessary handling for optional fields and for ensuring the required fields are present.

```ufo
// Optional field
field?: Type
```

#### Field documentation

You can add documentation to your fields to help the developer understand how to
use them. It's recommended to be concise and use single line descriptions.

```ufo
type User {
  """ The user's email address """
  email: string

  """ The user's full name """
  name: string
}
```

## Defining Procedures

Procedures are the main building block of your API. They define the procedures
(AKA functions) that can be implemented on the server and called from the
client.

```ufo
"""
<Procedure documentation>
"""
proc <ProcedureName> {
  input {
    """ <Field documentation> """
    <field>[?]: <PrimitiveType> | <CustomType>
  }

  output {
    """ <Field documentation> """
    <field>[?]: <PrimitiveType> | <CustomType>
  }
}
```

### Procedure documentation

You can add documentation to your procedures to help the developer understand
how to use them, they can include Markdown syntax that will be rendered in the
generated documentation.

### Procedure input

The input of a procedure defines the parameters that are sent to the server for
processing.

The fields inside the `input` block can also have their own documentation. It's
recommended to be concise and use single line descriptions.

### Procedure output

The output defines the structure of the response data.

The fields inside the `output` block can also have their own documentation. It's
recommended to be concise and use single line descriptions.

## Defining Streams

Streams allow server-to-client real-time communication using Server-Sent Events
(SSE). They enable unidirectional data flow from the server to subscribed
clients.

```ufo
"""
<Stream documentation>
"""
stream <StreamName> {
  input {
    """ <Field documentation> """
    <field>[?]: <PrimitiveType> | <CustomType>
  }

  output {
    """ <Field documentation> """
    <field>[?]: <PrimitiveType> | <CustomType>
  }
}
```

### Stream documentation

You can add documentation to your streams to help developers understand their
purpose and usage. Documentation can include Markdown syntax.

### Stream input

The input section defines the parameters required to establish a stream
subscription. These parameters determine what data the client wants to receive.

The fields inside the `input` block can also have their own documentation. It's
recommended to be concise and use single line descriptions.

### Stream output

The output section defines the structure of events that will be emitted through
the stream. Each event sent to the client will conform to this structure.

The fields inside the `output` block can also have their own documentation. It's
recommended to be concise and use single line descriptions.

### Example

```ufo
"""
Stream of new messages in a specific chat room
"""
stream NewMessage {
  input {
    chatId: string
  }

  output {
    id: string
    message: string
    userId: string
    timestamp: datetime
  }
}
```

## Documentation

### Docstrings

Docstrings can be used in two ways: associated with specific elements (types,
procedures, streams or fields) or as standalone documentation.

1.  Associated docstrings: These are placed immediately before a type, procedure,
    stream or field definition and provide specific documentation for that element.

    ```ufo
    """
    This is documentation for MyType.
    """
    type MyType {
      """ This is documentation for myField. """
      myField: string
    }
    ```

2.  Standalone docstrings: These provide general documentation for the schema and
    are not associated with any specific element. To create a standalone
    docstring, ensure there is at least one blank line between the docstring and
    any following element.

    ```ufo
    """
    This is general documentation for the entire schema.
    It can include multiple paragraphs and Markdown formatting.
    """

    // At least one blank line here

    type MyType {
      // ...
    }
    ```

#### Multi-line Docstrings and Indentation

Docstrings support Markdown syntax, allowing you to format your documentation
with headings, lists, code blocks, and more.

Since docstrings can contain Markdown, whitespace is significant for formatting constructs like lists or code blocks. To prevent conflicts with URPC's own syntax indentation, UFO RPC automatically normalizes multi-line docstrings.

The leading whitespace from the first non-empty line is considered the baseline indentation. This baseline is then removed from every line in the docstring. This process preserves the _relative_ indentation, ensuring that Markdown formatting remains intact regardless of how the docstring block is indented in the source file.

_Example:_

In the following docstring, the first line has 4 spaces of indentation, which will be removed from all lines.

```ufo
type MyType {
  """
    This is a multi-line docstring.

    The list below will be rendered correctly:

    - Level 1
      - Level 2
  """
  field: string
}
```

The resulting content for rendering will be:

```markdown
This is a multi-line docstring.

The list below will be rendered correctly:

- Level 1
  - Level 2
```

Remember to keep your documentation up to date with your schema changes.

### External Documentation Files

For extensive documentation, you can reference external Markdown files:

```ufo
version 1

// Standalone documentation
""" ./docs/welcome.md """
""" ./docs/authentication.md """

// Associated documentation
""" ./docs/myproc.md """
proc MyProc {
  // ...
}
```

When a docstring contains only a valid path to a Markdown file, the content of
that file will be used as documentation. This approach helps maintain clean and
focused schema files while allowing for detailed documentation in separate
files.

Remember to keep external documentation files up to date with your schema
changes.

## Deprecation

URPC provides a mechanism to mark types, procedures, and streams as deprecated,
indicating they should no longer be used in new code and may be removed in
future versions.

### Basic Deprecation

To mark an element as deprecated without a specific message, use the
`deprecated` keyword before the element definition:

```ufo
deprecated type MyType {
  // type definition
}

deprecated proc MyProc {
  // procedure definition
}

deprecated stream MyStream {
  // stream definition
}
```

### Deprecation with Message

To provide additional information about the deprecation, include a message in
parentheses:

```ufo
deprecated("Replaced by ImprovedType")
type MyType {
  // type definition
}

deprecated("This procedure will be removed in v2.0")
proc MyProc {
  // procedure definition
}

deprecated("Use NewMessageStream instead")
stream MyStream {
  // stream definition
}
```

### Placement

The `deprecated` keyword must be placed between any docstring and the element
definition (type, proc, or stream):

```ufo
"""
Documentation for MyType
"""
deprecated("Use NewType instead")
type MyType {
  // type definition
}
```

### Effects

Deprecated elements will:

- Be displayed with special styling in the playground to discourage their use
- Generate warning comments in the output code to discourage their use
- Not change their behavior in the generated code, it's just a warning

## Complete Example

```ufo
version 1

""" ./docs/welcome.md """
""" ./docs/authentication.md """

"""
Base entity with common fields
"""
type BaseEntity {
  id: string
  createdAt: datetime
  updatedAt: datetime
}

"""
Represents a product in the catalog
"""
type Product {
  base: BaseEntity

  """ The name of the product. """
  name: string

  """ The price of the product. """
  price: float

  """ The date when the product will be available. """
  availabilityDate: datetime

  """ A list of tags for the product. """
  tags?: string[]
}

"""
Represents a review of a product
"""
type Review {
  """ The rating of the review, from 1 to 5. """
  rating: int

  """ The comment of the review. """
  comment: string
}

"""
Creates a new product in the system and returns the product id.
"""
proc CreateProduct {
  input {
    product: Product
  }

  output {
    success: bool
    productId: string
  }
}

"""
Get a product by id with its reviews.
"""
proc GetProduct {
  input {
    productId: string
  }

  output {
    product: Product
    reviews: Review[]
  }
}

"""
Sends a message to a chat room
"""
proc SendMessage {
  input {
    """ The id of the chat room to send the message to. """
    chatId: string

    """ The content of the message. """
    message: string
  }

  output {
    """ The id of the message that was sent. """
    messageId: string

    """ The timestamp of when the message was sent. """
    timestamp: datetime
  }
}

"""
Stream of new messages in a specific chat room
"""
stream NewMessage {
  input {
    chatId: string
  }

  output {
    id: string
    message: string
    userId: string
    timestamp: datetime
  }
}
```

## Limitations

1. Keywords can't be used as identifiers
2. Complex validation logic (other than type checking and required fields) is your responsibility
