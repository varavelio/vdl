package python

import (
	"context"
	_ "embed"
	"strings"

	"github.com/varavelio/gen"
	"github.com/varavelio/vdl/toolchain/internal/codegen/config"
	"github.com/varavelio/vdl/toolchain/internal/core/ir"
	"github.com/varavelio/vdl/toolchain/internal/util/strutil"
	"github.com/varavelio/vdl/toolchain/internal/version"
)

// File represents a generated file.
type File struct {
	RelativePath string
	Content      []byte
}

// Generator implements the Python code generator.
type Generator struct {
	config *config.PythonConfig
}

// New creates a new Python generator with the given config.
func New(config *config.PythonConfig) *Generator {
	return &Generator{config: config}
}

// Name returns the generator name.
func (g *Generator) Name() string {
	return "python"
}

// generateHeader generates the file header.
func generateHeader() string {
	g := gen.New()
	g.Linef("# Code generated by VDL v%s. DO NOT EDIT.", version.Version)
	g.Line("# If you edit this file, it will be overwritten the next time it is generated.")
	g.Line("#")
	g.Line("# For more information about VDL, visit https://vdl.varavel.com")
	g.Break()
	return g.String()
}

// Generate produces Python source files from the IR schema.
func (g *Generator) Generate(ctx context.Context, schema *ir.Schema) ([]File, error) {
	var files []File

	// __init__.py - Exports all files
	indexContent := g.generateIndexFile(schema)
	files = append(files, File{
		RelativePath: "__init__.py",
		Content:      []byte(indexContent),
	})

	// core.py - Core VDL types (Response, VdlError)
	coreContent := g.generateCoreFile(schema)
	files = append(files, File{
		RelativePath: "core.py",
		Content:      []byte(coreContent),
	})

	// constants.py - Constants (if enabled and any exist)
	if g.config.ShouldGenConsts() && len(schema.Constants) > 0 {
		constantsContent := g.generateConstantsFile(schema)
		files = append(files, File{
			RelativePath: "constants.py",
			Content:      []byte(constantsContent),
		})
	}

	// patterns.py - Pattern functions (if enabled and any exist)
	if g.config.ShouldGenPatterns() && len(schema.Patterns) > 0 {
		patternsContent := g.generatePatternsFile(schema)
		files = append(files, File{
			RelativePath: "patterns.py",
			Content:      []byte(patternsContent),
		})
	}

	// types.py - Enums, Domain types, Procedures and Streams (if any exist)
	hasTypes := len(schema.Enums) > 0 || len(schema.Types) > 0 || len(schema.Procedures) > 0 || len(schema.Streams) > 0
	if hasTypes {
		typesContent := g.generateTypesFile(schema)
		files = append(files, File{
			RelativePath: "types.py",
			Content:      []byte(typesContent),
		})
	}

	// catalog.py - RPC catalog for introspection (if any RPCs)
	if len(schema.RPCs) > 0 {
		catalogContent := g.generateRPCCatalogFile(schema)
		files = append(files, File{
			RelativePath: "catalog.py",
			Content:      []byte(catalogContent),
		})
	}

	// Pseudo-format files
	for i := range files {
		content := string(files[i].Content)
		content = strings.TrimSpace(content)
		content = strutil.LimitConsecutiveNewlines(content, 2)
		content += "\n"
		files[i].Content = []byte(content)
	}

	return files, nil
}

// generateCoreFile generates the core_types.py file.
func (g *Generator) generateCoreFile(schema *ir.Schema) string {
	builder := gen.New()
	builder.Raw(generateHeader())

	coreContent, _ := generateCore(schema, g.config)
	builder.Raw(coreContent)

	return builder.String()
}

// generateConstantsFile generates the constants.py file.
func (g *Generator) generateConstantsFile(schema *ir.Schema) string {
	builder := gen.New()
	builder.Raw(generateHeader())

	constantsContent, _ := generateConstants(schema, g.config)
	builder.Raw(strings.TrimSpace(constantsContent))

	return builder.String()
}

// generatePatternsFile generates the patterns.py file.
func (g *Generator) generatePatternsFile(schema *ir.Schema) string {
	builder := gen.New()
	builder.Raw(generateHeader())

	patternsContent, _ := generatePatterns(schema, g.config)
	builder.Raw(strings.TrimSpace(patternsContent))

	return builder.String()
}

// generateTypesFile generates the types.py file.
func (g *Generator) generateTypesFile(schema *ir.Schema) string {
	builder := gen.New()
	builder.Raw(generateHeader())

	// Basic imports
	builder.Line("from __future__ import annotations")
	builder.Line("from dataclasses import dataclass")
	builder.Line("from enum import Enum, IntEnum")
	builder.Line("from typing import Any, Dict, List, Optional, Union")
	builder.Line("import datetime")
	builder.Break()
	builder.Line("from .core import Response, VdlError")
	builder.Break()

	// Generate enums
	if len(schema.Enums) > 0 {
		enumsContent, _ := generateEnums(schema, g.config)
		builder.Raw(strings.TrimSpace(enumsContent))
		builder.Break()
		builder.Break()
	}

	// Generate domain types
	if len(schema.Types) > 0 {
		typesContent, _ := generateDomainTypes(schema, g.config)
		builder.Raw(strings.TrimSpace(typesContent))
		builder.Break()
		builder.Break()
	}

	// Generate procedure types
	if len(schema.Procedures) > 0 {
		procContent, _ := generateProcedureTypes(schema, g.config)
		builder.Raw(strings.TrimSpace(procContent))
		builder.Break()
		builder.Break()
	}

	// Generate stream types
	if len(schema.Streams) > 0 {
		streamContent, _ := generateStreamTypes(schema, g.config)
		builder.Raw(strings.TrimSpace(streamContent))
	}

	return builder.String()
}

// generateRPCCatalogFile generates the rpc_catalog.py file.
func (g *Generator) generateRPCCatalogFile(schema *ir.Schema) string {
	builder := gen.New()
	builder.Raw(generateHeader())

	catalogContent, _ := generateRPCCatalog(schema, g.config)
	builder.Raw(strings.TrimSpace(catalogContent))

	return builder.String()
}

// generateIndexFile generates the __init__.py file.
func (g *Generator) generateIndexFile(schema *ir.Schema) string {
	builder := gen.New()
	builder.Raw(generateHeader())

	// Core types
	builder.Line("from .core import *")

	// Constants
	if g.config.ShouldGenConsts() && len(schema.Constants) > 0 {
		builder.Line("from .constants import *")
	}

	// Patterns
	if g.config.ShouldGenPatterns() && len(schema.Patterns) > 0 {
		builder.Line("from .patterns import *")
	}

	// Types
	hasTypes := len(schema.Enums) > 0 || len(schema.Types) > 0 || len(schema.Procedures) > 0 || len(schema.Streams) > 0
	if hasTypes {
		builder.Line("from .types import *")
	}

	// RPC Catalog
	if len(schema.RPCs) > 0 {
		builder.Line("from .catalog import *")
	}

	return builder.String()
}
