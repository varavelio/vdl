package dart

import (
	"context"
	_ "embed"
	"strings"

	"github.com/varavelio/gen"
	"github.com/varavelio/vdl/toolchain/internal/codegen/config"
	"github.com/varavelio/vdl/toolchain/internal/core/ir"
	"github.com/varavelio/vdl/toolchain/internal/util/strutil"
	"github.com/varavelio/vdl/toolchain/internal/version"
)

// File represents a generated file. This mirrors codegen.File to avoid import cycles.
type File struct {
	RelativePath string
	Content      []byte
}

// Generator implements the Dart code generator.
type Generator struct {
	config *config.DartConfig
}

// New creates a new Dart generator with the given config.
func New(config *config.DartConfig) *Generator {
	return &Generator{config: config}
}

// Name returns the generator name.
func (g *Generator) Name() string {
	return "dart"
}

// generateHeader generates the file header matching Go format (without license info).
func generateHeader() string {
	g := gen.New().WithSpaces(2)
	g.Linef("// Code generated by VDL v%s. DO NOT EDIT.", version.Version)
	g.Line("// If you edit this file, it will be overwritten the next time it is generated.")
	g.Line("//")
	g.Line("// For more information about VDL, visit https://vdl.varavel.com")
	g.Break()
	return g.String()
}

// Generate produces Dart source files from the IR schema.
func (g *Generator) Generate(ctx context.Context, schema *ir.Schema) ([]File, error) {
	var files []File

	// core.dart - Core VDL types (Response, VdlError)
	coreContent := g.generateCoreFile(schema)
	files = append(files, File{
		RelativePath: "core.dart",
		Content:      []byte(coreContent),
	})

	// constants.dart - Constants (if enabled and any exist)
	if g.config.ShouldGenConsts() && len(schema.Constants) > 0 {
		constantsContent := g.generateConstantsFile(schema)
		files = append(files, File{
			RelativePath: "constants.dart",
			Content:      []byte(constantsContent),
		})
	}

	// patterns.dart - Pattern functions (if enabled and any exist)
	if g.config.ShouldGenPatterns() && len(schema.Patterns) > 0 {
		patternsContent := g.generatePatternsFile(schema)
		files = append(files, File{
			RelativePath: "patterns.dart",
			Content:      []byte(patternsContent),
		})
	}

	// types.dart - Enums, Domain types, Procedures and Streams (if any exist)
	hasTypes := len(schema.Enums) > 0 || len(schema.Types) > 0 || len(schema.Procedures) > 0 || len(schema.Streams) > 0
	if hasTypes {
		typesContent := g.generateTypesFile(schema)
		files = append(files, File{
			RelativePath: "types.dart",
			Content:      []byte(typesContent),
		})
	}

	// catalog.dart - RPC catalog for introspection (if any RPCs)
	if len(schema.RPCs) > 0 {
		catalogContent := g.generateRPCCatalogFile(schema)
		files = append(files, File{
			RelativePath: "catalog.dart",
			Content:      []byte(catalogContent),
		})
	}

	// index.dart - Re-exports all files
	indexContent := g.generateIndexFile(schema)
	files = append(files, File{
		RelativePath: "index.dart",
		Content:      []byte(indexContent),
	})

	// Pseudo format generated files
	for i := range files {
		content := string(files[i].Content)
		content = strings.TrimSpace(content)
		content = strutil.LimitConsecutiveNewlines(content, 2)
		content += "\n"
		files[i].Content = []byte(content)
	}

	return files, nil
}

// generateCoreFile generates the core.dart file.
func (g *Generator) generateCoreFile(schema *ir.Schema) string {
	builder := gen.New().WithSpaces(2)
	builder.Raw(generateHeader())

	coreContent, _ := generateCore(schema, g.config)
	builder.Raw(coreContent)

	content := builder.String()
	return strutil.LimitConsecutiveNewlines(content, 2)
}

// generateConstantsFile generates the constants.dart file.
func (g *Generator) generateConstantsFile(schema *ir.Schema) string {
	builder := gen.New().WithSpaces(2)
	builder.Raw(generateHeader())

	constantsContent, _ := generateConstants(schema, g.config)
	builder.Raw(strings.TrimSpace(constantsContent))

	content := builder.String()
	return strutil.LimitConsecutiveNewlines(content, 2)
}

// generatePatternsFile generates the patterns.dart file.
func (g *Generator) generatePatternsFile(schema *ir.Schema) string {
	builder := gen.New().WithSpaces(2)
	builder.Raw(generateHeader())

	patternsContent, _ := generatePatterns(schema, g.config)
	builder.Raw(strings.TrimSpace(patternsContent))

	content := builder.String()
	return strutil.LimitConsecutiveNewlines(content, 2)
}

// generateTypesFile generates the types.dart file (includes enums, domain types, procedures and streams).
func (g *Generator) generateTypesFile(schema *ir.Schema) string {
	builder := gen.New().WithSpaces(2)
	builder.Raw(generateHeader())

	// Add import for core if we have procedures or streams
	if len(schema.Procedures) > 0 || len(schema.Streams) > 0 {
		builder.Line("import 'core.dart';")
		builder.Break()
	}

	// Generate enums first
	if len(schema.Enums) > 0 {
		enumsContent, _ := generateEnums(schema, g.config)
		builder.Raw(strings.TrimSpace(enumsContent))
		builder.Break()
		builder.Break()
	}

	// Generate domain types
	if len(schema.Types) > 0 {
		typesContent, _ := generateDomainTypes(schema, g.config)
		builder.Raw(strings.TrimSpace(typesContent))
		builder.Break()
		builder.Break()
	}

	// Generate procedure types
	if len(schema.Procedures) > 0 {
		procContent, _ := generateProcedureTypes(schema, g.config)
		builder.Raw(strings.TrimSpace(procContent))
		builder.Break()
		builder.Break()
	}

	// Generate stream types
	if len(schema.Streams) > 0 {
		streamContent, _ := generateStreamTypes(schema, g.config)
		builder.Raw(strings.TrimSpace(streamContent))
	}

	content := builder.String()
	return strutil.LimitConsecutiveNewlines(content, 2)
}

// generateRPCCatalogFile generates the catalog.dart file.
func (g *Generator) generateRPCCatalogFile(schema *ir.Schema) string {
	builder := gen.New().WithSpaces(2)
	builder.Raw(generateHeader())

	catalogContent, _ := generateRPCCatalog(schema, g.config)
	builder.Raw(strings.TrimSpace(catalogContent))

	content := builder.String()
	return strutil.LimitConsecutiveNewlines(content, 2)
}

// generateIndexFile generates the index.dart file with re-exports.
func (g *Generator) generateIndexFile(schema *ir.Schema) string {
	builder := gen.New().WithSpaces(2)
	builder.Raw(generateHeader())

	builder.Line("// This file re-exports all generated VDL types.")
	builder.Line("// Import this file to access all generated code.")
	builder.Break()

	// Always export core
	builder.Line("export 'core.dart';")

	// Conditionally export other files
	if g.config.ShouldGenConsts() && len(schema.Constants) > 0 {
		builder.Line("export 'constants.dart';")
	}

	if g.config.ShouldGenPatterns() && len(schema.Patterns) > 0 {
		builder.Line("export 'patterns.dart';")
	}

	// types.dart contains enums, domain types, procedures and streams
	hasTypes := len(schema.Enums) > 0 || len(schema.Types) > 0 || len(schema.Procedures) > 0 || len(schema.Streams) > 0
	if hasTypes {
		builder.Line("export 'types.dart';")
	}

	if len(schema.RPCs) > 0 {
		builder.Line("export 'catalog.dart';")
	}

	content := builder.String()
	return strutil.LimitConsecutiveNewlines(content, 2)
}
