// Code generated by UFO RPC. DO NOT EDIT.
// If you edit this file, it will be overwritten the next time it is generated.
//
// This file is licensed under the MIT License.
// See https://github.com/uforg/uforpc for more information.
//
// Copyright (c) [Generated by UFO RPC - User retains copyright]
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// ignore_for_file: unused_element, unused_field

import 'dart:async';
import 'dart:convert' as convert;
import 'dart:math' as math;
import 'package:http/http.dart' as http;

// -----------------------------------------------------------------------------
// Core Types
// -----------------------------------------------------------------------------

/// Response represents the response of a UFO RPC call.
class Response<T> {
  /// Indicates whether the RPC call was successful.
  final bool ok;

  /// The successful output (only present if `ok == true`).
  final T? output;

  /// Structured error (only present if `ok == false`).
  final UfoError? error;

  const Response._({required this.ok, this.output, this.error});

  factory Response.ok(T output) => Response._(ok: true, output: output);

  factory Response.error(UfoError error) => Response._(ok: false, error: error);

  factory Response.fromJson(Map<String, dynamic> json) {
    if (json['ok'] == true) {
      return Response.ok(json['output'] as T);
    }
    final err = json['error'];
    return Response.error(
      err is Map<String, dynamic>
          ? UfoError.fromJson(err)
          : UfoError(message: err?.toString() ?? 'Unknown error'),
    );
  }

  Map<String, dynamic> toJson() {
    if (ok) {
      return {'ok': true, 'output': output};
    }
    return {'ok': false, 'error': error?.toJson()};
  }
}

/// Structured error type used throughout the UFO RPC ecosystem.
class UfoError implements Exception {
  /// Human-readable description of the error.
  final String message;

  /// Categorizes the error by its nature or source (e.g., "ValidationError").
  final String? category;

  /// Machine-readable identifier for the specific error condition.
  final String? code;

  /// Additional information about the error.
  final Map<String, dynamic>? details;

  UfoError({required this.message, this.category, this.code, this.details});

  factory UfoError.fromJson(Map<String, dynamic> json) => UfoError(
        message: json['message']?.toString() ?? 'Unknown error',
        category: json['category'] as String?,
        code: json['code'] as String?,
        details: json['details'] is Map
            ? (json['details'] as Map).cast<String, dynamic>()
            : null,
      );

  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{'message': message};
    if (category != null) data['category'] = category;
    if (code != null) data['code'] = code;
    if (details != null) data['details'] = details;
    return data;
  }

  @override
  String toString() =>
      'UfoError(message: ' + message + ', code: ' + (code ?? '-') + ')';
}

/// Normalises arbitrary error inputs into a `UfoError` instance.
UfoError _asError(Object err) {
  if (err is UfoError) return err;
  return UfoError(message: err.toString());
}

/// Sleep for the given number of milliseconds.
Future<void> _sleep(int ms) => Future<void>.delayed(Duration(milliseconds: ms));

// -----------------------------------------------------------------------------
// Configuration Types (internal)
// -----------------------------------------------------------------------------

/// Configuration for automatic retry behavior in procedures.
class RetryConfig {
  final int maxAttempts;
  final int initialDelayMs;
  final int maxDelayMs;
  final double delayMultiplier;

  const RetryConfig({
    this.maxAttempts = 3,
    this.initialDelayMs = 1000,
    this.maxDelayMs = 5000,
    this.delayMultiplier = 2.0,
  });

  factory RetryConfig.sanitised(RetryConfig c) => RetryConfig(
        maxAttempts: c.maxAttempts < 0 ? 0 : c.maxAttempts,
        initialDelayMs: c.initialDelayMs < 100 ? 100 : c.initialDelayMs,
        maxDelayMs: c.maxDelayMs < 100 ? 100 : c.maxDelayMs,
        delayMultiplier: c.delayMultiplier < 1 ? 1 : c.delayMultiplier,
      );
}

/// Configuration for timeout behavior in procedures.
class TimeoutConfig {
  final int timeoutMs;
  const TimeoutConfig({this.timeoutMs = 30000});
  factory TimeoutConfig.sanitised(TimeoutConfig c) =>
      TimeoutConfig(timeoutMs: c.timeoutMs < 100 ? 100 : c.timeoutMs);
}

/// Configuration for automatic reconnection behavior in streams.
class ReconnectConfig {
  final int maxAttempts;
  final int initialDelayMs;
  final int maxDelayMs;
  final double delayMultiplier;

  const ReconnectConfig({
    this.maxAttempts = 5,
    this.initialDelayMs = 1000,
    this.maxDelayMs = 5000,
    this.delayMultiplier = 2.0,
  });

  factory ReconnectConfig.sanitised(ReconnectConfig c) => ReconnectConfig(
        maxAttempts: c.maxAttempts < 0 ? 0 : c.maxAttempts,
        initialDelayMs: c.initialDelayMs < 100 ? 100 : c.initialDelayMs,
        maxDelayMs: c.maxDelayMs < 100 ? 100 : c.maxDelayMs,
        delayMultiplier: c.delayMultiplier < 1 ? 1 : c.delayMultiplier,
      );
}

// -----------------------------------------------------------------------------
// Internal Client (http-based)
// -----------------------------------------------------------------------------

class _InternalClient {
  final String _baseURL;
  final Set<String> _procSet;
  final Set<String> _streamSet;
  final Map<String, String> _globalHeaders;
  final http.Client _client = http.Client();

  _InternalClient(
    this._baseURL,
    List<String> procNames,
    List<String> streamNames,
    Map<String, String> globalHeaders,
  )   : _procSet = Set.of(procNames),
        _streamSet = Set.of(streamNames),
        _globalHeaders = Map.of(globalHeaders);

  void addGlobalHeader(String k, String v) {
    _globalHeaders[k] = v;
  }

  Future<Response<dynamic>> callProc(
    String name,
    Object? input,
    Map<String, String> headers,
    RetryConfig? retryConfig,
    TimeoutConfig? timeoutConfig,
  ) async {
    final retryConf = retryConfig ?? const RetryConfig();
    final timeoutConf = timeoutConfig ?? const TimeoutConfig();

    if (!_procSet.contains(name)) {
      return Response.error(
        UfoError(
          message: '$name procedure not found in schema',
          category: 'ClientError',
          code: 'INVALID_PROC',
        ),
      );
    }

    String payload;
    try {
      payload = input == null ? '{}' : convert.jsonEncode(input);
    } catch (err) {
      return Response.error(_asError(err));
    }

    final url = "${_baseURL.replaceAll(RegExp(r"/+$"), '')}/$name";
    final hdrs = <String, String>{
      'content-type': 'application/json',
      'accept': 'application/json',
      ..._globalHeaders,
      ...headers,
    };

    UfoError? lastError;
    for (var attempt = 1; attempt <= retryConf.maxAttempts; attempt++) {
      try {
        final uri = Uri.parse(url);
        final resp = await _client
            .post(uri, headers: hdrs, body: payload)
            .timeout(Duration(milliseconds: timeoutConf.timeoutMs));

        if (resp.statusCode < 200 || resp.statusCode >= 300) {
          final error = UfoError(
            message: 'Unexpected HTTP status: ${resp.statusCode}',
            category: 'HTTPError',
            code: 'BAD_STATUS',
            details: {'status': resp.statusCode, 'attempt': attempt},
          );
          if (resp.statusCode >= 500 && attempt < retryConf.maxAttempts) {
            lastError = error;
            final backoffMs = _backoffMs(retryConf, attempt);
            await _sleep(backoffMs);
            continue;
          }
          return Response.error(error);
        }

        final bodyText = resp.body;
        try {
          final parsed = convert.jsonDecode(bodyText);
          if (parsed is Map<String, dynamic>) {
            return Response<dynamic>.fromJson(parsed);
          }
          return Response.error(UfoError(message: 'Invalid JSON response'));
        } catch (err) {
          return Response.error(_asError(err));
        }
      } on TimeoutException {
        final timeoutError = UfoError(
          message: 'Request timeout after ${timeoutConf.timeoutMs}ms',
          category: 'TimeoutError',
          code: 'REQUEST_TIMEOUT',
          details: {'timeoutMs': timeoutConf.timeoutMs, 'attempt': attempt},
        );
        if (attempt < retryConf.maxAttempts) {
          lastError = timeoutError;
          final backoffMs = _backoffMs(retryConf, attempt);
          await _sleep(backoffMs);
          continue;
        }
        return Response.error(timeoutError);
      } catch (err) {
        final error = _asError(err);
        if (attempt < retryConf.maxAttempts) {
          lastError = error;
          final backoffMs = _backoffMs(retryConf, attempt);
          await _sleep(backoffMs);
          continue;
        }
        return Response.error(error);
      }
    }

    return Response.error(lastError ?? UfoError(message: 'Unknown error'));
  }

  _StreamHandle<dynamic> callStream(
    String name,
    Object? input,
    Map<String, String> headers,
    ReconnectConfig? reconnectConfig,
  ) {
    final reconnectConf = reconnectConfig ?? const ReconnectConfig();

    var isCancelled = false;
    final streamClient = http.Client();

    void cancel() {
      isCancelled = true;
      try {
        streamClient.close();
      } catch (_) {}
    }

    Stream<Response<dynamic>> generator() async* {
      if (!_streamSet.contains(name)) {
        yield Response.error(
          UfoError(
            message: '$name stream not found in schema',
            category: 'ClientError',
            code: 'INVALID_STREAM',
          ),
        );
        return;
      }

      String payload;
      try {
        payload = input == null ? '{}' : convert.jsonEncode(input);
      } catch (err) {
        yield Response.error(_asError(err));
        return;
      }

      final url = "${_baseURL.replaceAll(RegExp(r"/+$"), '')}/$name";
      final hdrs = <String, String>{
        'content-type': 'application/json',
        'accept': 'text/event-stream',
        ..._globalHeaders,
        ...headers,
      };

      var reconnectAttempt = 0;
      while (!isCancelled) {
        try {
          final uri = Uri.parse(url);
          final req = http.Request('POST', uri);
          req.headers.addAll(hdrs);
          req.body = payload;

          final streamed = await streamClient.send(req);
          if (streamed.statusCode < 200 || streamed.statusCode >= 300) {
            final error = UfoError(
              message: 'Unexpected HTTP status: ${streamed.statusCode}',
              category: 'HTTPError',
              code: 'BAD_STATUS',
              details: {
                'status': streamed.statusCode,
                'reconnectAttempt': reconnectAttempt,
              },
            );
            if (!isCancelled &&
                streamed.statusCode >= 500 &&
                reconnectAttempt < reconnectConf.maxAttempts) {
              yield Response.error(error);
              reconnectAttempt++;
              final delayMs = _reconnectDelayMs(
                reconnectConf,
                reconnectAttempt,
              );
              await _sleep(delayMs);
              continue;
            }
            yield Response.error(error);
            return;
          }

          reconnectAttempt = 0;

          final decoder = convert.Utf8Decoder();
          var buffer = '';

          await for (final chunk in streamed.stream) {
            if (isCancelled) break;
            buffer += decoder.convert(chunk);
            int idx;
            while ((idx = buffer.indexOf('\n\n')) != -1) {
              final line = buffer.substring(0, idx).trimRight();
              buffer = buffer.substring(idx + 2);
              if (line.isEmpty) continue;
              if (line.startsWith('data:')) {
                final jsonStr = line.substring(5).trim();
                try {
                  final dynamic parsed = convert.jsonDecode(jsonStr);
                  if (parsed is Map<String, dynamic>) {
                    yield Response<dynamic>.fromJson(parsed);
                  } else {
                    yield Response.error(
                      UfoError(message: 'Invalid event JSON'),
                    );
                    return;
                  }
                } catch (err) {
                  yield Response.error(_asError(err));
                  return;
                }
              }
            }
          }

          if (!isCancelled) return; // ended naturally
        } catch (err) {
          if (!isCancelled && reconnectAttempt < reconnectConf.maxAttempts) {
            yield Response.error(
              UfoError(
                message:
                    'Stream connection issue, attempting reconnect (${reconnectAttempt + 1}/${reconnectConf.maxAttempts})',
                category: 'ConnectionError',
                code: 'STREAM_INTERRUPTED',
                details: {'reconnectAttempt': reconnectAttempt + 1},
              ),
            );
            reconnectAttempt++;
            final delayMs = _reconnectDelayMs(reconnectConf, reconnectAttempt);
            await _sleep(delayMs);
            continue;
          }
          if (!isCancelled) {
            yield Response.error(_asError(err));
          }
          return;
        } finally {
          try {
            // Stream client persists for this call; closed by cancel()
          } catch (_) {}
        }
      }
    }

    return _StreamHandle<dynamic>(stream: generator(), cancel: cancel);
  }
}

int _backoffMs(RetryConfig conf, int attempt) {
  final exp = math
      .pow(conf.delayMultiplier == 0 ? 1 : conf.delayMultiplier, attempt - 1)
      .toDouble();
  final delay = conf.initialDelayMs * exp;
  final bounded = delay < 0
      ? 0
      : (delay > conf.maxDelayMs.toDouble()
          ? conf.maxDelayMs.toDouble()
          : delay);
  return bounded.toInt();
}

int _reconnectDelayMs(ReconnectConfig conf, int attempt) {
  final exp = math
      .pow(conf.delayMultiplier == 0 ? 1 : conf.delayMultiplier, attempt - 1)
      .toDouble();
  final delay = conf.initialDelayMs * exp;
  final bounded = delay < 0
      ? 0
      : (delay > conf.maxDelayMs.toDouble()
          ? conf.maxDelayMs.toDouble()
          : delay);
  return bounded.toInt();
}

class _StreamHandle<T> {
  final Stream<Response<T>> stream;
  final void Function() cancel;
  _StreamHandle({required this.stream, required this.cancel});
}

class _InternalClientBuilder {
  final String _baseURL;
  final Map<String, String> _headers = {};
  _InternalClientBuilder(this._baseURL);
  void withGlobalHeader(String key, String value) => _headers[key] = value;
  _InternalClient build(List<String> procNames, List<String> streamNames) =>
      _InternalClient(_baseURL, procNames, streamNames, _headers);
}
