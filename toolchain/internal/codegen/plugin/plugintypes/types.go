// Code generated by VDL v0.4.0-alpha.5. DO NOT EDIT.
// If you edit this file, it will be overwritten the next time it is generated.

// Package plugintypes contains generated code for VDL.
//
// For more information about VDL, visit https://vdl.varavel.com
package plugintypes

import (
	"encoding/json"
	"fmt"
)

// -----------------------------------------------------------------------------
// Enumerations
// -----------------------------------------------------------------------------

// Underlying storage kind used by an enum
type EnumType string

// EnumType enum values
const (
	EnumTypeString EnumType = "string"
	EnumTypeInt    EnumType = "int"
)

// EnumTypeList contains all valid EnumType values.
var EnumTypeList = []EnumType{
	EnumTypeString,
	EnumTypeInt,
}

// String returns the string representation of EnumType.
func (e EnumType) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid EnumType.
func (e EnumType) IsValid() bool {
	switch e {
	case EnumTypeString, EnumTypeInt:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid EnumType member.
func (e EnumType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum EnumType", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid EnumType member.
func (e *EnumType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := EnumType(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum EnumType", s)
	}

	*e = v
	return nil
}

// Primitive scalar type names
type PrimitiveType string

// PrimitiveType enum values
const (
	PrimitiveTypeString   PrimitiveType = "string"
	PrimitiveTypeInt      PrimitiveType = "int"
	PrimitiveTypeFloat    PrimitiveType = "float"
	PrimitiveTypeBool     PrimitiveType = "bool"
	PrimitiveTypeDatetime PrimitiveType = "datetime"
)

// PrimitiveTypeList contains all valid PrimitiveType values.
var PrimitiveTypeList = []PrimitiveType{
	PrimitiveTypeString,
	PrimitiveTypeInt,
	PrimitiveTypeFloat,
	PrimitiveTypeBool,
	PrimitiveTypeDatetime,
}

// String returns the string representation of PrimitiveType.
func (e PrimitiveType) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid PrimitiveType.
func (e PrimitiveType) IsValid() bool {
	switch e {
	case PrimitiveTypeString, PrimitiveTypeInt, PrimitiveTypeFloat, PrimitiveTypeBool, PrimitiveTypeDatetime:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid PrimitiveType member.
func (e PrimitiveType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum PrimitiveType", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid PrimitiveType member.
func (e *PrimitiveType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := PrimitiveType(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum PrimitiveType", s)
	}

	*e = v
	return nil
}

// Kind discriminator for TypeRef
type TypeKind string

// TypeKind enum values
const (
	TypeKindPrimitive TypeKind = "primitive"
	TypeKindType      TypeKind = "type"
	TypeKindEnum      TypeKind = "enum"
	TypeKindArray     TypeKind = "array"
	TypeKindMap       TypeKind = "map"
	TypeKindObject    TypeKind = "object"
)

// TypeKindList contains all valid TypeKind values.
var TypeKindList = []TypeKind{
	TypeKindPrimitive,
	TypeKindType,
	TypeKindEnum,
	TypeKindArray,
	TypeKindMap,
	TypeKindObject,
}

// String returns the string representation of TypeKind.
func (e TypeKind) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid TypeKind.
func (e TypeKind) IsValid() bool {
	switch e {
	case TypeKindPrimitive, TypeKindType, TypeKindEnum, TypeKindArray, TypeKindMap, TypeKindObject:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid TypeKind member.
func (e TypeKind) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum TypeKind", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid TypeKind member.
func (e *TypeKind) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := TypeKind(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum TypeKind", s)
	}

	*e = v
	return nil
}

// Kind discriminator for Value.
//
// Value is used for fully resolved literal data in:
// - constant values
// - annotation arguments
type ValueKind string

// ValueKind enum values
const (
	ValueKindString ValueKind = "string"
	ValueKindInt    ValueKind = "int"
	ValueKindFloat  ValueKind = "float"
	ValueKindBool   ValueKind = "bool"
	ValueKindObject ValueKind = "object"
	ValueKindArray  ValueKind = "array"
)

// ValueKindList contains all valid ValueKind values.
var ValueKindList = []ValueKind{
	ValueKindString,
	ValueKindInt,
	ValueKindFloat,
	ValueKindBool,
	ValueKindObject,
	ValueKindArray,
}

// String returns the string representation of ValueKind.
func (e ValueKind) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid ValueKind.
func (e ValueKind) IsValid() bool {
	switch e {
	case ValueKindString, ValueKindInt, ValueKindFloat, ValueKindBool, ValueKindObject, ValueKindArray:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid ValueKind member.
func (e ValueKind) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum ValueKind", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid ValueKind member.
func (e *ValueKind) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := ValueKind(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum ValueKind", s)
	}

	*e = v
	return nil
}

// -----------------------------------------------------------------------------
// Domain Types
// -----------------------------------------------------------------------------

// Annotation metadata preserved in IR.
//
// `name` is the annotation identifier without the `@` prefix.
// `argument`, when present, is fully resolved as a Value.
type Annotation struct {
	// Annotation name without `@`
	Name string `json:"name"`
	// Optional resolved argument payload
	Argument *Value `json:"argument,omitempty"`
}

// GetName returns the value of Name or the zero value if the receiver or field is nil.
func (x *Annotation) GetName() string {
	if x != nil {
		return x.Name
	}
	var zero string
	return zero
}

// GetNameOr returns the value of Name or the provided default if the receiver or field is nil.
func (x *Annotation) GetNameOr(defaultValue string) string {
	if x != nil {
		return x.Name
	}
	return defaultValue
}

// GetArgument returns the value of Argument or the zero value if the receiver or field is nil.
func (x *Annotation) GetArgument() Value {
	if x != nil && x.Argument != nil {
		return *x.Argument
	}
	var zero Value
	return zero
}

// GetArgumentOr returns the value of Argument or the provided default if the receiver or field is nil.
func (x *Annotation) GetArgumentOr(defaultValue Value) Value {
	if x != nil && x.Argument != nil {
		return *x.Argument
	}
	return defaultValue
}

// preAnnotation is the version of Annotation previous to the required field validation
type preAnnotation struct {
	Name     *string   `json:"name,omitempty"`
	Argument *preValue `json:"argument,omitempty"`
}

// validate validates the required fields of Annotation
func (p *preAnnotation) validate() error {
	if p == nil {
		return errorMissingRequiredField("preAnnotation is nil")
	}

	// Validation for field "name"
	if p.Name == nil {
		return errorMissingRequiredField("field name is required")
	}

	// Validation for field "argument"
	if p.Argument != nil {
		if err := p.Argument.validate(); err != nil {
			return errorMissingRequiredField("field argument: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preAnnotation type to the final Annotation type
func (p *preAnnotation) transform() Annotation {
	// Transformations
	transName := *p.Name
	var transArgument *Value
	if p.Argument != nil {
		var valArgument Value
		valArgument = p.Argument.transform()
		transArgument = &valArgument
	}

	// Assignments
	return Annotation{
		Name:     transName,
		Argument: transArgument,
	}
}

// Fully resolved constant definition.
//
// `typeRef` is explicit or inferred by analysis.
// `value` contains the fully resolved literal payload.
type ConstantDef struct {
	// Constant name
	Name string `json:"name"`
	// Optional constant documentation
	Doc *string `json:"doc,omitempty"`
	// Constant annotations in source order
	Annotations []Annotation `json:"annotations"`
	// Normalized constant type reference (explicit or inferred)
	TypeRef TypeRef `json:"typeRef"`
	// Fully resolved constant value
	Value Value `json:"value"`
}

// GetName returns the value of Name or the zero value if the receiver or field is nil.
func (x *ConstantDef) GetName() string {
	if x != nil {
		return x.Name
	}
	var zero string
	return zero
}

// GetNameOr returns the value of Name or the provided default if the receiver or field is nil.
func (x *ConstantDef) GetNameOr(defaultValue string) string {
	if x != nil {
		return x.Name
	}
	return defaultValue
}

// GetDoc returns the value of Doc or the zero value if the receiver or field is nil.
func (x *ConstantDef) GetDoc() string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	var zero string
	return zero
}

// GetDocOr returns the value of Doc or the provided default if the receiver or field is nil.
func (x *ConstantDef) GetDocOr(defaultValue string) string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	return defaultValue
}

// GetAnnotations returns the value of Annotations or the zero value if the receiver or field is nil.
func (x *ConstantDef) GetAnnotations() []Annotation {
	if x != nil {
		return x.Annotations
	}
	var zero []Annotation
	return zero
}

// GetAnnotationsOr returns the value of Annotations or the provided default if the receiver or field is nil.
func (x *ConstantDef) GetAnnotationsOr(defaultValue []Annotation) []Annotation {
	if x != nil {
		return x.Annotations
	}
	return defaultValue
}

// GetTypeRef returns the value of TypeRef or the zero value if the receiver or field is nil.
func (x *ConstantDef) GetTypeRef() TypeRef {
	if x != nil {
		return x.TypeRef
	}
	var zero TypeRef
	return zero
}

// GetTypeRefOr returns the value of TypeRef or the provided default if the receiver or field is nil.
func (x *ConstantDef) GetTypeRefOr(defaultValue TypeRef) TypeRef {
	if x != nil {
		return x.TypeRef
	}
	return defaultValue
}

// GetValue returns the value of Value or the zero value if the receiver or field is nil.
func (x *ConstantDef) GetValue() Value {
	if x != nil {
		return x.Value
	}
	var zero Value
	return zero
}

// GetValueOr returns the value of Value or the provided default if the receiver or field is nil.
func (x *ConstantDef) GetValueOr(defaultValue Value) Value {
	if x != nil {
		return x.Value
	}
	return defaultValue
}

// preConstantDef is the version of ConstantDef previous to the required field validation
type preConstantDef struct {
	Name        *string          `json:"name,omitempty"`
	Doc         *string          `json:"doc,omitempty"`
	Annotations *[]preAnnotation `json:"annotations,omitempty"`
	TypeRef     *preTypeRef      `json:"typeRef,omitempty"`
	Value       *preValue        `json:"value,omitempty"`
}

// validate validates the required fields of ConstantDef
func (p *preConstantDef) validate() error {
	if p == nil {
		return errorMissingRequiredField("preConstantDef is nil")
	}

	// Validation for field "name"
	if p.Name == nil {
		return errorMissingRequiredField("field name is required")
	}

	// Validation for field "doc"

	// Validation for field "annotations"
	if p.Annotations == nil {
		return errorMissingRequiredField("field annotations is required")
	}
	if p.Annotations != nil {
		for _, item := range *p.Annotations {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field annotations: " + err.Error())
			}
		}
	}

	// Validation for field "typeRef"
	if p.TypeRef == nil {
		return errorMissingRequiredField("field typeRef is required")
	}
	if p.TypeRef != nil {
		if err := p.TypeRef.validate(); err != nil {
			return errorMissingRequiredField("field typeRef: " + err.Error())
		}
	}

	// Validation for field "value"
	if p.Value == nil {
		return errorMissingRequiredField("field value is required")
	}
	if p.Value != nil {
		if err := p.Value.validate(); err != nil {
			return errorMissingRequiredField("field value: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preConstantDef type to the final ConstantDef type
func (p *preConstantDef) transform() ConstantDef {
	// Transformations
	transName := *p.Name
	transDoc := p.Doc
	var transAnnotations []Annotation
	transAnnotations = make([]Annotation, len(*p.Annotations))
	for i, v := range *p.Annotations {
		var tmp_ Annotation
		tmp_ = v.transform()
		transAnnotations[i] = tmp_
	}
	var transTypeRef TypeRef
	transTypeRef = p.TypeRef.transform()
	var transValue Value
	transValue = p.Value.transform()

	// Assignments
	return ConstantDef{
		Name:        transName,
		Doc:         transDoc,
		Annotations: transAnnotations,
		TypeRef:     transTypeRef,
		Value:       transValue,
	}
}

// Standalone documentation block.
//
// Used for top-level docstrings that are not attached to a type/enum/constant.
type DocDef struct {
	// Resolved documentation content
	Content string `json:"content"`
}

// GetContent returns the value of Content or the zero value if the receiver or field is nil.
func (x *DocDef) GetContent() string {
	if x != nil {
		return x.Content
	}
	var zero string
	return zero
}

// GetContentOr returns the value of Content or the provided default if the receiver or field is nil.
func (x *DocDef) GetContentOr(defaultValue string) string {
	if x != nil {
		return x.Content
	}
	return defaultValue
}

// preDocDef is the version of DocDef previous to the required field validation
type preDocDef struct {
	Content *string `json:"content,omitempty"`
}

// validate validates the required fields of DocDef
func (p *preDocDef) validate() error {
	if p == nil {
		return errorMissingRequiredField("preDocDef is nil")
	}

	// Validation for field "content"
	if p.Content == nil {
		return errorMissingRequiredField("field content is required")
	}

	return nil
}

// transform transforms the preDocDef type to the final DocDef type
func (p *preDocDef) transform() DocDef {
	// Transformations
	transContent := *p.Content

	// Assignments
	return DocDef{
		Content: transContent,
	}
}

// Flattened enum definition.
//
// All enum spreads are already expanded into `members`.
type EnumDef struct {
	// Enum name
	Name string `json:"name"`
	// Optional enum documentation
	Doc *string `json:"doc,omitempty"`
	// Enum annotations in source order
	Annotations []Annotation `json:"annotations"`
	// Enum underlying storage kind
	EnumType EnumType `json:"enumType"`
	// Enum members in source order after spread expansion
	Members []EnumDefMember `json:"members"`
}

// GetName returns the value of Name or the zero value if the receiver or field is nil.
func (x *EnumDef) GetName() string {
	if x != nil {
		return x.Name
	}
	var zero string
	return zero
}

// GetNameOr returns the value of Name or the provided default if the receiver or field is nil.
func (x *EnumDef) GetNameOr(defaultValue string) string {
	if x != nil {
		return x.Name
	}
	return defaultValue
}

// GetDoc returns the value of Doc or the zero value if the receiver or field is nil.
func (x *EnumDef) GetDoc() string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	var zero string
	return zero
}

// GetDocOr returns the value of Doc or the provided default if the receiver or field is nil.
func (x *EnumDef) GetDocOr(defaultValue string) string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	return defaultValue
}

// GetAnnotations returns the value of Annotations or the zero value if the receiver or field is nil.
func (x *EnumDef) GetAnnotations() []Annotation {
	if x != nil {
		return x.Annotations
	}
	var zero []Annotation
	return zero
}

// GetAnnotationsOr returns the value of Annotations or the provided default if the receiver or field is nil.
func (x *EnumDef) GetAnnotationsOr(defaultValue []Annotation) []Annotation {
	if x != nil {
		return x.Annotations
	}
	return defaultValue
}

// GetEnumType returns the value of EnumType or the zero value if the receiver or field is nil.
func (x *EnumDef) GetEnumType() EnumType {
	if x != nil {
		return x.EnumType
	}
	var zero EnumType
	return zero
}

// GetEnumTypeOr returns the value of EnumType or the provided default if the receiver or field is nil.
func (x *EnumDef) GetEnumTypeOr(defaultValue EnumType) EnumType {
	if x != nil {
		return x.EnumType
	}
	return defaultValue
}

// GetMembers returns the value of Members or the zero value if the receiver or field is nil.
func (x *EnumDef) GetMembers() []EnumDefMember {
	if x != nil {
		return x.Members
	}
	var zero []EnumDefMember
	return zero
}

// GetMembersOr returns the value of Members or the provided default if the receiver or field is nil.
func (x *EnumDef) GetMembersOr(defaultValue []EnumDefMember) []EnumDefMember {
	if x != nil {
		return x.Members
	}
	return defaultValue
}

// preEnumDef is the version of EnumDef previous to the required field validation
type preEnumDef struct {
	Name        *string             `json:"name,omitempty"`
	Doc         *string             `json:"doc,omitempty"`
	Annotations *[]preAnnotation    `json:"annotations,omitempty"`
	EnumType    *EnumType           `json:"enumType,omitempty"`
	Members     *[]preEnumDefMember `json:"members,omitempty"`
}

// validate validates the required fields of EnumDef
func (p *preEnumDef) validate() error {
	if p == nil {
		return errorMissingRequiredField("preEnumDef is nil")
	}

	// Validation for field "name"
	if p.Name == nil {
		return errorMissingRequiredField("field name is required")
	}

	// Validation for field "doc"

	// Validation for field "annotations"
	if p.Annotations == nil {
		return errorMissingRequiredField("field annotations is required")
	}
	if p.Annotations != nil {
		for _, item := range *p.Annotations {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field annotations: " + err.Error())
			}
		}
	}

	// Validation for field "enumType"
	if p.EnumType == nil {
		return errorMissingRequiredField("field enumType is required")
	}

	// Validation for field "members"
	if p.Members == nil {
		return errorMissingRequiredField("field members is required")
	}
	if p.Members != nil {
		for _, item := range *p.Members {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field members: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preEnumDef type to the final EnumDef type
func (p *preEnumDef) transform() EnumDef {
	// Transformations
	transName := *p.Name
	transDoc := p.Doc
	var transAnnotations []Annotation
	transAnnotations = make([]Annotation, len(*p.Annotations))
	for i, v := range *p.Annotations {
		var tmp_ Annotation
		tmp_ = v.transform()
		transAnnotations[i] = tmp_
	}
	transEnumType := *p.EnumType
	var transMembers []EnumDefMember
	transMembers = make([]EnumDefMember, len(*p.Members))
	for i, v := range *p.Members {
		var tmp_ EnumDefMember
		tmp_ = v.transform()
		transMembers[i] = tmp_
	}

	// Assignments
	return EnumDef{
		Name:        transName,
		Doc:         transDoc,
		Annotations: transAnnotations,
		EnumType:    transEnumType,
		Members:     transMembers,
	}
}

// Enum member definition
type EnumDefMember struct {
	// Member name
	Name string `json:"name"`
	// Canonical string representation of the member value
	Value string `json:"value"`
	// Optional member documentation
	Doc *string `json:"doc,omitempty"`
	// Member annotations in source order
	Annotations []Annotation `json:"annotations"`
}

// GetName returns the value of Name or the zero value if the receiver or field is nil.
func (x *EnumDefMember) GetName() string {
	if x != nil {
		return x.Name
	}
	var zero string
	return zero
}

// GetNameOr returns the value of Name or the provided default if the receiver or field is nil.
func (x *EnumDefMember) GetNameOr(defaultValue string) string {
	if x != nil {
		return x.Name
	}
	return defaultValue
}

// GetValue returns the value of Value or the zero value if the receiver or field is nil.
func (x *EnumDefMember) GetValue() string {
	if x != nil {
		return x.Value
	}
	var zero string
	return zero
}

// GetValueOr returns the value of Value or the provided default if the receiver or field is nil.
func (x *EnumDefMember) GetValueOr(defaultValue string) string {
	if x != nil {
		return x.Value
	}
	return defaultValue
}

// GetDoc returns the value of Doc or the zero value if the receiver or field is nil.
func (x *EnumDefMember) GetDoc() string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	var zero string
	return zero
}

// GetDocOr returns the value of Doc or the provided default if the receiver or field is nil.
func (x *EnumDefMember) GetDocOr(defaultValue string) string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	return defaultValue
}

// GetAnnotations returns the value of Annotations or the zero value if the receiver or field is nil.
func (x *EnumDefMember) GetAnnotations() []Annotation {
	if x != nil {
		return x.Annotations
	}
	var zero []Annotation
	return zero
}

// GetAnnotationsOr returns the value of Annotations or the provided default if the receiver or field is nil.
func (x *EnumDefMember) GetAnnotationsOr(defaultValue []Annotation) []Annotation {
	if x != nil {
		return x.Annotations
	}
	return defaultValue
}

// preEnumDefMember is the version of EnumDefMember previous to the required field validation
type preEnumDefMember struct {
	Name        *string          `json:"name,omitempty"`
	Value       *string          `json:"value,omitempty"`
	Doc         *string          `json:"doc,omitempty"`
	Annotations *[]preAnnotation `json:"annotations,omitempty"`
}

// validate validates the required fields of EnumDefMember
func (p *preEnumDefMember) validate() error {
	if p == nil {
		return errorMissingRequiredField("preEnumDefMember is nil")
	}

	// Validation for field "name"
	if p.Name == nil {
		return errorMissingRequiredField("field name is required")
	}

	// Validation for field "value"
	if p.Value == nil {
		return errorMissingRequiredField("field value is required")
	}

	// Validation for field "doc"

	// Validation for field "annotations"
	if p.Annotations == nil {
		return errorMissingRequiredField("field annotations is required")
	}
	if p.Annotations != nil {
		for _, item := range *p.Annotations {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field annotations: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preEnumDefMember type to the final EnumDefMember type
func (p *preEnumDefMember) transform() EnumDefMember {
	// Transformations
	transName := *p.Name
	transValue := *p.Value
	transDoc := p.Doc
	var transAnnotations []Annotation
	transAnnotations = make([]Annotation, len(*p.Annotations))
	for i, v := range *p.Annotations {
		var tmp_ Annotation
		tmp_ = v.transform()
		transAnnotations[i] = tmp_
	}

	// Assignments
	return EnumDefMember{
		Name:        transName,
		Value:       transValue,
		Doc:         transDoc,
		Annotations: transAnnotations,
	}
}

// Flattened object/type field definition
type Field struct {
	// Field name
	Name string `json:"name"`
	// Optional field documentation
	Doc *string `json:"doc,omitempty"`
	// True when the field is optional (`?`)
	Optional bool `json:"optional"`
	// Field annotations in source order
	Annotations []Annotation `json:"annotations"`
	// Normalized field type reference
	TypeRef TypeRef `json:"typeRef"`
}

// GetName returns the value of Name or the zero value if the receiver or field is nil.
func (x *Field) GetName() string {
	if x != nil {
		return x.Name
	}
	var zero string
	return zero
}

// GetNameOr returns the value of Name or the provided default if the receiver or field is nil.
func (x *Field) GetNameOr(defaultValue string) string {
	if x != nil {
		return x.Name
	}
	return defaultValue
}

// GetDoc returns the value of Doc or the zero value if the receiver or field is nil.
func (x *Field) GetDoc() string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	var zero string
	return zero
}

// GetDocOr returns the value of Doc or the provided default if the receiver or field is nil.
func (x *Field) GetDocOr(defaultValue string) string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	return defaultValue
}

// GetOptional returns the value of Optional or the zero value if the receiver or field is nil.
func (x *Field) GetOptional() bool {
	if x != nil {
		return x.Optional
	}
	var zero bool
	return zero
}

// GetOptionalOr returns the value of Optional or the provided default if the receiver or field is nil.
func (x *Field) GetOptionalOr(defaultValue bool) bool {
	if x != nil {
		return x.Optional
	}
	return defaultValue
}

// GetAnnotations returns the value of Annotations or the zero value if the receiver or field is nil.
func (x *Field) GetAnnotations() []Annotation {
	if x != nil {
		return x.Annotations
	}
	var zero []Annotation
	return zero
}

// GetAnnotationsOr returns the value of Annotations or the provided default if the receiver or field is nil.
func (x *Field) GetAnnotationsOr(defaultValue []Annotation) []Annotation {
	if x != nil {
		return x.Annotations
	}
	return defaultValue
}

// GetTypeRef returns the value of TypeRef or the zero value if the receiver or field is nil.
func (x *Field) GetTypeRef() TypeRef {
	if x != nil {
		return x.TypeRef
	}
	var zero TypeRef
	return zero
}

// GetTypeRefOr returns the value of TypeRef or the provided default if the receiver or field is nil.
func (x *Field) GetTypeRefOr(defaultValue TypeRef) TypeRef {
	if x != nil {
		return x.TypeRef
	}
	return defaultValue
}

// preField is the version of Field previous to the required field validation
type preField struct {
	Name        *string          `json:"name,omitempty"`
	Doc         *string          `json:"doc,omitempty"`
	Optional    *bool            `json:"optional,omitempty"`
	Annotations *[]preAnnotation `json:"annotations,omitempty"`
	TypeRef     *preTypeRef      `json:"typeRef,omitempty"`
}

// validate validates the required fields of Field
func (p *preField) validate() error {
	if p == nil {
		return errorMissingRequiredField("preField is nil")
	}

	// Validation for field "name"
	if p.Name == nil {
		return errorMissingRequiredField("field name is required")
	}

	// Validation for field "doc"

	// Validation for field "optional"
	if p.Optional == nil {
		return errorMissingRequiredField("field optional is required")
	}

	// Validation for field "annotations"
	if p.Annotations == nil {
		return errorMissingRequiredField("field annotations is required")
	}
	if p.Annotations != nil {
		for _, item := range *p.Annotations {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field annotations: " + err.Error())
			}
		}
	}

	// Validation for field "typeRef"
	if p.TypeRef == nil {
		return errorMissingRequiredField("field typeRef is required")
	}
	if p.TypeRef != nil {
		if err := p.TypeRef.validate(); err != nil {
			return errorMissingRequiredField("field typeRef: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preField type to the final Field type
func (p *preField) transform() Field {
	// Transformations
	transName := *p.Name
	transDoc := p.Doc
	transOptional := *p.Optional
	var transAnnotations []Annotation
	transAnnotations = make([]Annotation, len(*p.Annotations))
	for i, v := range *p.Annotations {
		var tmp_ Annotation
		tmp_ = v.transform()
		transAnnotations[i] = tmp_
	}
	var transTypeRef TypeRef
	transTypeRef = p.TypeRef.transform()

	// Assignments
	return Field{
		Name:        transName,
		Doc:         transDoc,
		Optional:    transOptional,
		Annotations: transAnnotations,
		TypeRef:     transTypeRef,
	}
}

// IrSchema is the generator-facing representation of a VDL program.
//
// This model is intentionally "flat" and "resolved":
// - spreads are already expanded
// - references are already resolved
// - collections are in deterministic order
//
// A code generator should be able to consume IrSchema directly, without needing
// to re-run parser or semantic-analysis logic.
type IrSchema struct {
	// Constant definitions, sorted by name
	Constants []ConstantDef `json:"constants"`
	// Enum definitions, sorted by name
	Enums []EnumDef `json:"enums"`
	// Type definitions, sorted by name
	Types []TypeDef `json:"types"`
	// Standalone documentation blocks in source traversal order
	Docs []DocDef `json:"docs"`
}

// GetConstants returns the value of Constants or the zero value if the receiver or field is nil.
func (x *IrSchema) GetConstants() []ConstantDef {
	if x != nil {
		return x.Constants
	}
	var zero []ConstantDef
	return zero
}

// GetConstantsOr returns the value of Constants or the provided default if the receiver or field is nil.
func (x *IrSchema) GetConstantsOr(defaultValue []ConstantDef) []ConstantDef {
	if x != nil {
		return x.Constants
	}
	return defaultValue
}

// GetEnums returns the value of Enums or the zero value if the receiver or field is nil.
func (x *IrSchema) GetEnums() []EnumDef {
	if x != nil {
		return x.Enums
	}
	var zero []EnumDef
	return zero
}

// GetEnumsOr returns the value of Enums or the provided default if the receiver or field is nil.
func (x *IrSchema) GetEnumsOr(defaultValue []EnumDef) []EnumDef {
	if x != nil {
		return x.Enums
	}
	return defaultValue
}

// GetTypes returns the value of Types or the zero value if the receiver or field is nil.
func (x *IrSchema) GetTypes() []TypeDef {
	if x != nil {
		return x.Types
	}
	var zero []TypeDef
	return zero
}

// GetTypesOr returns the value of Types or the provided default if the receiver or field is nil.
func (x *IrSchema) GetTypesOr(defaultValue []TypeDef) []TypeDef {
	if x != nil {
		return x.Types
	}
	return defaultValue
}

// GetDocs returns the value of Docs or the zero value if the receiver or field is nil.
func (x *IrSchema) GetDocs() []DocDef {
	if x != nil {
		return x.Docs
	}
	var zero []DocDef
	return zero
}

// GetDocsOr returns the value of Docs or the provided default if the receiver or field is nil.
func (x *IrSchema) GetDocsOr(defaultValue []DocDef) []DocDef {
	if x != nil {
		return x.Docs
	}
	return defaultValue
}

// preIrSchema is the version of IrSchema previous to the required field validation
type preIrSchema struct {
	Constants *[]preConstantDef `json:"constants,omitempty"`
	Enums     *[]preEnumDef     `json:"enums,omitempty"`
	Types     *[]preTypeDef     `json:"types,omitempty"`
	Docs      *[]preDocDef      `json:"docs,omitempty"`
}

// validate validates the required fields of IrSchema
func (p *preIrSchema) validate() error {
	if p == nil {
		return errorMissingRequiredField("preIrSchema is nil")
	}

	// Validation for field "constants"
	if p.Constants == nil {
		return errorMissingRequiredField("field constants is required")
	}
	if p.Constants != nil {
		for _, item := range *p.Constants {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field constants: " + err.Error())
			}
		}
	}

	// Validation for field "enums"
	if p.Enums == nil {
		return errorMissingRequiredField("field enums is required")
	}
	if p.Enums != nil {
		for _, item := range *p.Enums {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field enums: " + err.Error())
			}
		}
	}

	// Validation for field "types"
	if p.Types == nil {
		return errorMissingRequiredField("field types is required")
	}
	if p.Types != nil {
		for _, item := range *p.Types {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field types: " + err.Error())
			}
		}
	}

	// Validation for field "docs"
	if p.Docs == nil {
		return errorMissingRequiredField("field docs is required")
	}
	if p.Docs != nil {
		for _, item := range *p.Docs {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field docs: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preIrSchema type to the final IrSchema type
func (p *preIrSchema) transform() IrSchema {
	// Transformations
	var transConstants []ConstantDef
	transConstants = make([]ConstantDef, len(*p.Constants))
	for i, v := range *p.Constants {
		var tmp_ ConstantDef
		tmp_ = v.transform()
		transConstants[i] = tmp_
	}
	var transEnums []EnumDef
	transEnums = make([]EnumDef, len(*p.Enums))
	for i, v := range *p.Enums {
		var tmp_ EnumDef
		tmp_ = v.transform()
		transEnums[i] = tmp_
	}
	var transTypes []TypeDef
	transTypes = make([]TypeDef, len(*p.Types))
	for i, v := range *p.Types {
		var tmp_ TypeDef
		tmp_ = v.transform()
		transTypes[i] = tmp_
	}
	var transDocs []DocDef
	transDocs = make([]DocDef, len(*p.Docs))
	for i, v := range *p.Docs {
		var tmp_ DocDef
		tmp_ = v.transform()
		transDocs[i] = tmp_
	}

	// Assignments
	return IrSchema{
		Constants: transConstants,
		Enums:     transEnums,
		Types:     transTypes,
		Docs:      transDocs,
	}
}

// Key/value pair inside an object Value payload
type ObjectEntry struct {
	// Object key
	Key string `json:"key"`
	// Fully resolved value for this key
	Value Value `json:"value"`
}

// GetKey returns the value of Key or the zero value if the receiver or field is nil.
func (x *ObjectEntry) GetKey() string {
	if x != nil {
		return x.Key
	}
	var zero string
	return zero
}

// GetKeyOr returns the value of Key or the provided default if the receiver or field is nil.
func (x *ObjectEntry) GetKeyOr(defaultValue string) string {
	if x != nil {
		return x.Key
	}
	return defaultValue
}

// GetValue returns the value of Value or the zero value if the receiver or field is nil.
func (x *ObjectEntry) GetValue() Value {
	if x != nil {
		return x.Value
	}
	var zero Value
	return zero
}

// GetValueOr returns the value of Value or the provided default if the receiver or field is nil.
func (x *ObjectEntry) GetValueOr(defaultValue Value) Value {
	if x != nil {
		return x.Value
	}
	return defaultValue
}

// preObjectEntry is the version of ObjectEntry previous to the required field validation
type preObjectEntry struct {
	Key   *string   `json:"key,omitempty"`
	Value *preValue `json:"value,omitempty"`
}

// validate validates the required fields of ObjectEntry
func (p *preObjectEntry) validate() error {
	if p == nil {
		return errorMissingRequiredField("preObjectEntry is nil")
	}

	// Validation for field "key"
	if p.Key == nil {
		return errorMissingRequiredField("field key is required")
	}

	// Validation for field "value"
	if p.Value == nil {
		return errorMissingRequiredField("field value is required")
	}
	if p.Value != nil {
		if err := p.Value.validate(); err != nil {
			return errorMissingRequiredField("field value: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preObjectEntry type to the final ObjectEntry type
func (p *preObjectEntry) transform() ObjectEntry {
	// Transformations
	transKey := *p.Key
	var transValue Value
	transValue = p.Value.transform()

	// Assignments
	return ObjectEntry{
		Key:   transKey,
		Value: transValue,
	}
}

// PluginInput represents the data payload sent to a plugin via stdin.
//
// The plugin receives this as a single JSON object containing the complete
// Intermediate Representation of the VDL schema along with any user-defined
// configuration options from vdl.yaml.
type PluginInput struct {
	// The VDL binary version (without v prefix, e.g. 1.0.0)
	Version string `json:"version"`
	// The complete VDL Intermediate Representation.
	//
	// Contains all types, enums, constants, patterns, RPCs, procedures, streams,
	// and documentation blocks from the compiled schema, fully resolved and ready
	// for code generation.
	Ir IrSchema `json:"ir"`
	// The complete VDL schema in plain text (with includes and external docstrings already resolved)
	Schema string `json:"schema"`
	// Arbitrary key-value options passed from the vdl.yaml configuration.
	//
	// These allow users to customize plugin behavior without modifying the plugin
	// itself. Common use cases include specifying target frameworks, API versions,
	// naming conventions, or feature flags.
	Options map[string]string `json:"options"`
}

// GetVersion returns the value of Version or the zero value if the receiver or field is nil.
func (x *PluginInput) GetVersion() string {
	if x != nil {
		return x.Version
	}
	var zero string
	return zero
}

// GetVersionOr returns the value of Version or the provided default if the receiver or field is nil.
func (x *PluginInput) GetVersionOr(defaultValue string) string {
	if x != nil {
		return x.Version
	}
	return defaultValue
}

// GetIr returns the value of Ir or the zero value if the receiver or field is nil.
func (x *PluginInput) GetIr() IrSchema {
	if x != nil {
		return x.Ir
	}
	var zero IrSchema
	return zero
}

// GetIrOr returns the value of Ir or the provided default if the receiver or field is nil.
func (x *PluginInput) GetIrOr(defaultValue IrSchema) IrSchema {
	if x != nil {
		return x.Ir
	}
	return defaultValue
}

// GetSchema returns the value of Schema or the zero value if the receiver or field is nil.
func (x *PluginInput) GetSchema() string {
	if x != nil {
		return x.Schema
	}
	var zero string
	return zero
}

// GetSchemaOr returns the value of Schema or the provided default if the receiver or field is nil.
func (x *PluginInput) GetSchemaOr(defaultValue string) string {
	if x != nil {
		return x.Schema
	}
	return defaultValue
}

// GetOptions returns the value of Options or the zero value if the receiver or field is nil.
func (x *PluginInput) GetOptions() map[string]string {
	if x != nil {
		return x.Options
	}
	var zero map[string]string
	return zero
}

// GetOptionsOr returns the value of Options or the provided default if the receiver or field is nil.
func (x *PluginInput) GetOptionsOr(defaultValue map[string]string) map[string]string {
	if x != nil {
		return x.Options
	}
	return defaultValue
}

// prePluginInput is the version of PluginInput previous to the required field validation
type prePluginInput struct {
	Version *string            `json:"version,omitempty"`
	Ir      *preIrSchema       `json:"ir,omitempty"`
	Schema  *string            `json:"schema,omitempty"`
	Options *map[string]string `json:"options,omitempty"`
}

// validate validates the required fields of PluginInput
func (p *prePluginInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("prePluginInput is nil")
	}

	// Validation for field "version"
	if p.Version == nil {
		return errorMissingRequiredField("field version is required")
	}

	// Validation for field "ir"
	if p.Ir == nil {
		return errorMissingRequiredField("field ir is required")
	}
	if p.Ir != nil {
		if err := p.Ir.validate(); err != nil {
			return errorMissingRequiredField("field ir: " + err.Error())
		}
	}

	// Validation for field "schema"
	if p.Schema == nil {
		return errorMissingRequiredField("field schema is required")
	}

	// Validation for field "options"
	if p.Options == nil {
		return errorMissingRequiredField("field options is required")
	}

	return nil
}

// transform transforms the prePluginInput type to the final PluginInput type
func (p *prePluginInput) transform() PluginInput {
	// Transformations
	transVersion := *p.Version
	var transIr IrSchema
	transIr = p.Ir.transform()
	transSchema := *p.Schema
	transOptions := *p.Options

	// Assignments
	return PluginInput{
		Version: transVersion,
		Ir:      transIr,
		Schema:  transSchema,
		Options: transOptions,
	}
}

// PluginOutput represents the response payload written by a plugin to stdout.
//
// After processing the input schema, the plugin outputs this JSON object
// containing all files to be generated. VDL then writes these files to the
// configured output directory.
type PluginOutput struct {
	// List of virtual files generated by the plugin.
	//
	// Each file specifies a relative path within the output directory and its
	// complete textual content. Paths may include subdirectories which VDL
	// will create automatically.
	//
	// If no files are returned, VDL will not write anything.
	Files *[]PluginOutputFile `json:"files,omitempty"`
}

// GetFiles returns the value of Files or the zero value if the receiver or field is nil.
func (x *PluginOutput) GetFiles() []PluginOutputFile {
	if x != nil && x.Files != nil {
		return *x.Files
	}
	var zero []PluginOutputFile
	return zero
}

// GetFilesOr returns the value of Files or the provided default if the receiver or field is nil.
func (x *PluginOutput) GetFilesOr(defaultValue []PluginOutputFile) []PluginOutputFile {
	if x != nil && x.Files != nil {
		return *x.Files
	}
	return defaultValue
}

// prePluginOutput is the version of PluginOutput previous to the required field validation
type prePluginOutput struct {
	Files *[]prePluginOutputFile `json:"files,omitempty"`
}

// validate validates the required fields of PluginOutput
func (p *prePluginOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("prePluginOutput is nil")
	}

	// Validation for field "files"
	if p.Files != nil {
		for _, item := range *p.Files {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field files: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the prePluginOutput type to the final PluginOutput type
func (p *prePluginOutput) transform() PluginOutput {
	// Transformations
	var transFiles *[]PluginOutputFile
	if p.Files != nil {
		var valFiles []PluginOutputFile
		valFiles = make([]PluginOutputFile, len(*p.Files))
		for i, v := range *p.Files {
			var tmp_ PluginOutputFile
			tmp_ = v.transform()
			valFiles[i] = tmp_
		}
		transFiles = &valFiles
	}

	// Assignments
	return PluginOutput{
		Files: transFiles,
	}
}

// PluginOutputFile represents a single generated file produced by the plugin.
//
// This abstraction allows plugins to generate multiple files from a single
// invocation, enabling patterns like one-file-per-type or splitting large
// outputs across multiple modules.
type PluginOutputFile struct {
	// Relative path from the output directory where this file should be written.
	//
	// May include subdirectory separators (e.g., "src/models/user.py").
	// Forward slashes are normalized to the appropriate separator for the
	// current operating system.
	Path string `json:"path"`
	// The complete textual content of the generated file.
	//
	// This should be the final, formatted output ready to be written to disk.
	// VDL writes this content as-is without additional processing.
	Content string `json:"content"`
}

// GetPath returns the value of Path or the zero value if the receiver or field is nil.
func (x *PluginOutputFile) GetPath() string {
	if x != nil {
		return x.Path
	}
	var zero string
	return zero
}

// GetPathOr returns the value of Path or the provided default if the receiver or field is nil.
func (x *PluginOutputFile) GetPathOr(defaultValue string) string {
	if x != nil {
		return x.Path
	}
	return defaultValue
}

// GetContent returns the value of Content or the zero value if the receiver or field is nil.
func (x *PluginOutputFile) GetContent() string {
	if x != nil {
		return x.Content
	}
	var zero string
	return zero
}

// GetContentOr returns the value of Content or the provided default if the receiver or field is nil.
func (x *PluginOutputFile) GetContentOr(defaultValue string) string {
	if x != nil {
		return x.Content
	}
	return defaultValue
}

// prePluginOutputFile is the version of PluginOutputFile previous to the required field validation
type prePluginOutputFile struct {
	Path    *string `json:"path,omitempty"`
	Content *string `json:"content,omitempty"`
}

// validate validates the required fields of PluginOutputFile
func (p *prePluginOutputFile) validate() error {
	if p == nil {
		return errorMissingRequiredField("prePluginOutputFile is nil")
	}

	// Validation for field "path"
	if p.Path == nil {
		return errorMissingRequiredField("field path is required")
	}

	// Validation for field "content"
	if p.Content == nil {
		return errorMissingRequiredField("field content is required")
	}

	return nil
}

// transform transforms the prePluginOutputFile type to the final PluginOutputFile type
func (p *prePluginOutputFile) transform() PluginOutputFile {
	// Transformations
	transPath := *p.Path
	transContent := *p.Content

	// Assignments
	return PluginOutputFile{
		Path:    transPath,
		Content: transContent,
	}
}

// Flattened type definition.
//
// All spreads are already expanded into `fields`.
type TypeDef struct {
	// Type name
	Name string `json:"name"`
	// Optional type documentation
	Doc *string `json:"doc,omitempty"`
	// Type annotations in source order
	Annotations []Annotation `json:"annotations"`
	// Type fields in source order
	Fields []Field `json:"fields"`
}

// GetName returns the value of Name or the zero value if the receiver or field is nil.
func (x *TypeDef) GetName() string {
	if x != nil {
		return x.Name
	}
	var zero string
	return zero
}

// GetNameOr returns the value of Name or the provided default if the receiver or field is nil.
func (x *TypeDef) GetNameOr(defaultValue string) string {
	if x != nil {
		return x.Name
	}
	return defaultValue
}

// GetDoc returns the value of Doc or the zero value if the receiver or field is nil.
func (x *TypeDef) GetDoc() string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	var zero string
	return zero
}

// GetDocOr returns the value of Doc or the provided default if the receiver or field is nil.
func (x *TypeDef) GetDocOr(defaultValue string) string {
	if x != nil && x.Doc != nil {
		return *x.Doc
	}
	return defaultValue
}

// GetAnnotations returns the value of Annotations or the zero value if the receiver or field is nil.
func (x *TypeDef) GetAnnotations() []Annotation {
	if x != nil {
		return x.Annotations
	}
	var zero []Annotation
	return zero
}

// GetAnnotationsOr returns the value of Annotations or the provided default if the receiver or field is nil.
func (x *TypeDef) GetAnnotationsOr(defaultValue []Annotation) []Annotation {
	if x != nil {
		return x.Annotations
	}
	return defaultValue
}

// GetFields returns the value of Fields or the zero value if the receiver or field is nil.
func (x *TypeDef) GetFields() []Field {
	if x != nil {
		return x.Fields
	}
	var zero []Field
	return zero
}

// GetFieldsOr returns the value of Fields or the provided default if the receiver or field is nil.
func (x *TypeDef) GetFieldsOr(defaultValue []Field) []Field {
	if x != nil {
		return x.Fields
	}
	return defaultValue
}

// preTypeDef is the version of TypeDef previous to the required field validation
type preTypeDef struct {
	Name        *string          `json:"name,omitempty"`
	Doc         *string          `json:"doc,omitempty"`
	Annotations *[]preAnnotation `json:"annotations,omitempty"`
	Fields      *[]preField      `json:"fields,omitempty"`
}

// validate validates the required fields of TypeDef
func (p *preTypeDef) validate() error {
	if p == nil {
		return errorMissingRequiredField("preTypeDef is nil")
	}

	// Validation for field "name"
	if p.Name == nil {
		return errorMissingRequiredField("field name is required")
	}

	// Validation for field "doc"

	// Validation for field "annotations"
	if p.Annotations == nil {
		return errorMissingRequiredField("field annotations is required")
	}
	if p.Annotations != nil {
		for _, item := range *p.Annotations {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field annotations: " + err.Error())
			}
		}
	}

	// Validation for field "fields"
	if p.Fields == nil {
		return errorMissingRequiredField("field fields is required")
	}
	if p.Fields != nil {
		for _, item := range *p.Fields {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field fields: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preTypeDef type to the final TypeDef type
func (p *preTypeDef) transform() TypeDef {
	// Transformations
	transName := *p.Name
	transDoc := p.Doc
	var transAnnotations []Annotation
	transAnnotations = make([]Annotation, len(*p.Annotations))
	for i, v := range *p.Annotations {
		var tmp_ Annotation
		tmp_ = v.transform()
		transAnnotations[i] = tmp_
	}
	var transFields []Field
	transFields = make([]Field, len(*p.Fields))
	for i, v := range *p.Fields {
		var tmp_ Field
		tmp_ = v.transform()
		transFields[i] = tmp_
	}

	// Assignments
	return TypeDef{
		Name:        transName,
		Doc:         transDoc,
		Annotations: transAnnotations,
		Fields:      transFields,
	}
}

// Normalized type reference used by fields and constants.
//
// `kind` selects which payload fields are meaningful. Generators should inspect
// `kind` first, then read the related payload fields.
type TypeRef struct {
	// Type category discriminator
	Kind TypeKind `json:"kind"`
	// Primitive type name when `kind` is `primitive`
	PrimitiveName *PrimitiveType `json:"primitiveName,omitempty"`
	// Referenced type name when `kind` is `type`
	TypeName *string `json:"typeName,omitempty"`
	// Referenced enum name when `kind` is `enum`
	EnumName *string `json:"enumName,omitempty"`
	// Referenced enum underlying kind when `kind` is `enum`
	EnumType *EnumType `json:"enumType,omitempty"`
	// Element type when `kind` is `array`
	ArrayType *TypeRef `json:"arrayType,omitempty"`
	// Array rank when `kind` is `array` (for example, 2 for `T[][]`)
	ArrayDims *int64 `json:"arrayDims,omitempty"`
	// Map value type when `kind` is `map`
	MapType *TypeRef `json:"mapType,omitempty"`
	// Inline object fields when `kind` is `object`
	ObjectFields *[]Field `json:"objectFields,omitempty"`
}

// GetKind returns the value of Kind or the zero value if the receiver or field is nil.
func (x *TypeRef) GetKind() TypeKind {
	if x != nil {
		return x.Kind
	}
	var zero TypeKind
	return zero
}

// GetKindOr returns the value of Kind or the provided default if the receiver or field is nil.
func (x *TypeRef) GetKindOr(defaultValue TypeKind) TypeKind {
	if x != nil {
		return x.Kind
	}
	return defaultValue
}

// GetPrimitiveName returns the value of PrimitiveName or the zero value if the receiver or field is nil.
func (x *TypeRef) GetPrimitiveName() PrimitiveType {
	if x != nil && x.PrimitiveName != nil {
		return *x.PrimitiveName
	}
	var zero PrimitiveType
	return zero
}

// GetPrimitiveNameOr returns the value of PrimitiveName or the provided default if the receiver or field is nil.
func (x *TypeRef) GetPrimitiveNameOr(defaultValue PrimitiveType) PrimitiveType {
	if x != nil && x.PrimitiveName != nil {
		return *x.PrimitiveName
	}
	return defaultValue
}

// GetTypeName returns the value of TypeName or the zero value if the receiver or field is nil.
func (x *TypeRef) GetTypeName() string {
	if x != nil && x.TypeName != nil {
		return *x.TypeName
	}
	var zero string
	return zero
}

// GetTypeNameOr returns the value of TypeName or the provided default if the receiver or field is nil.
func (x *TypeRef) GetTypeNameOr(defaultValue string) string {
	if x != nil && x.TypeName != nil {
		return *x.TypeName
	}
	return defaultValue
}

// GetEnumName returns the value of EnumName or the zero value if the receiver or field is nil.
func (x *TypeRef) GetEnumName() string {
	if x != nil && x.EnumName != nil {
		return *x.EnumName
	}
	var zero string
	return zero
}

// GetEnumNameOr returns the value of EnumName or the provided default if the receiver or field is nil.
func (x *TypeRef) GetEnumNameOr(defaultValue string) string {
	if x != nil && x.EnumName != nil {
		return *x.EnumName
	}
	return defaultValue
}

// GetEnumType returns the value of EnumType or the zero value if the receiver or field is nil.
func (x *TypeRef) GetEnumType() EnumType {
	if x != nil && x.EnumType != nil {
		return *x.EnumType
	}
	var zero EnumType
	return zero
}

// GetEnumTypeOr returns the value of EnumType or the provided default if the receiver or field is nil.
func (x *TypeRef) GetEnumTypeOr(defaultValue EnumType) EnumType {
	if x != nil && x.EnumType != nil {
		return *x.EnumType
	}
	return defaultValue
}

// GetArrayType returns the value of ArrayType or the zero value if the receiver or field is nil.
func (x *TypeRef) GetArrayType() TypeRef {
	if x != nil && x.ArrayType != nil {
		return *x.ArrayType
	}
	var zero TypeRef
	return zero
}

// GetArrayTypeOr returns the value of ArrayType or the provided default if the receiver or field is nil.
func (x *TypeRef) GetArrayTypeOr(defaultValue TypeRef) TypeRef {
	if x != nil && x.ArrayType != nil {
		return *x.ArrayType
	}
	return defaultValue
}

// GetArrayDims returns the value of ArrayDims or the zero value if the receiver or field is nil.
func (x *TypeRef) GetArrayDims() int64 {
	if x != nil && x.ArrayDims != nil {
		return *x.ArrayDims
	}
	var zero int64
	return zero
}

// GetArrayDimsOr returns the value of ArrayDims or the provided default if the receiver or field is nil.
func (x *TypeRef) GetArrayDimsOr(defaultValue int64) int64 {
	if x != nil && x.ArrayDims != nil {
		return *x.ArrayDims
	}
	return defaultValue
}

// GetMapType returns the value of MapType or the zero value if the receiver or field is nil.
func (x *TypeRef) GetMapType() TypeRef {
	if x != nil && x.MapType != nil {
		return *x.MapType
	}
	var zero TypeRef
	return zero
}

// GetMapTypeOr returns the value of MapType or the provided default if the receiver or field is nil.
func (x *TypeRef) GetMapTypeOr(defaultValue TypeRef) TypeRef {
	if x != nil && x.MapType != nil {
		return *x.MapType
	}
	return defaultValue
}

// GetObjectFields returns the value of ObjectFields or the zero value if the receiver or field is nil.
func (x *TypeRef) GetObjectFields() []Field {
	if x != nil && x.ObjectFields != nil {
		return *x.ObjectFields
	}
	var zero []Field
	return zero
}

// GetObjectFieldsOr returns the value of ObjectFields or the provided default if the receiver or field is nil.
func (x *TypeRef) GetObjectFieldsOr(defaultValue []Field) []Field {
	if x != nil && x.ObjectFields != nil {
		return *x.ObjectFields
	}
	return defaultValue
}

// preTypeRef is the version of TypeRef previous to the required field validation
type preTypeRef struct {
	Kind          *TypeKind      `json:"kind,omitempty"`
	PrimitiveName *PrimitiveType `json:"primitiveName,omitempty"`
	TypeName      *string        `json:"typeName,omitempty"`
	EnumName      *string        `json:"enumName,omitempty"`
	EnumType      *EnumType      `json:"enumType,omitempty"`
	ArrayType     *preTypeRef    `json:"arrayType,omitempty"`
	ArrayDims     *int64         `json:"arrayDims,omitempty"`
	MapType       *preTypeRef    `json:"mapType,omitempty"`
	ObjectFields  *[]preField    `json:"objectFields,omitempty"`
}

// validate validates the required fields of TypeRef
func (p *preTypeRef) validate() error {
	if p == nil {
		return errorMissingRequiredField("preTypeRef is nil")
	}

	// Validation for field "kind"
	if p.Kind == nil {
		return errorMissingRequiredField("field kind is required")
	}

	// Validation for field "primitiveName"

	// Validation for field "typeName"

	// Validation for field "enumName"

	// Validation for field "enumType"

	// Validation for field "arrayType"
	if p.ArrayType != nil {
		if err := p.ArrayType.validate(); err != nil {
			return errorMissingRequiredField("field arrayType: " + err.Error())
		}
	}

	// Validation for field "arrayDims"

	// Validation for field "mapType"
	if p.MapType != nil {
		if err := p.MapType.validate(); err != nil {
			return errorMissingRequiredField("field mapType: " + err.Error())
		}
	}

	// Validation for field "objectFields"
	if p.ObjectFields != nil {
		for _, item := range *p.ObjectFields {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field objectFields: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preTypeRef type to the final TypeRef type
func (p *preTypeRef) transform() TypeRef {
	// Transformations
	transKind := *p.Kind
	transPrimitiveName := p.PrimitiveName
	transTypeName := p.TypeName
	transEnumName := p.EnumName
	transEnumType := p.EnumType
	var transArrayType *TypeRef
	if p.ArrayType != nil {
		var valArrayType TypeRef
		valArrayType = p.ArrayType.transform()
		transArrayType = &valArrayType
	}
	transArrayDims := p.ArrayDims
	var transMapType *TypeRef
	if p.MapType != nil {
		var valMapType TypeRef
		valMapType = p.MapType.transform()
		transMapType = &valMapType
	}
	var transObjectFields *[]Field
	if p.ObjectFields != nil {
		var valObjectFields []Field
		valObjectFields = make([]Field, len(*p.ObjectFields))
		for i, v := range *p.ObjectFields {
			var tmp_ Field
			tmp_ = v.transform()
			valObjectFields[i] = tmp_
		}
		transObjectFields = &valObjectFields
	}

	// Assignments
	return TypeRef{
		Kind:          transKind,
		PrimitiveName: transPrimitiveName,
		TypeName:      transTypeName,
		EnumName:      transEnumName,
		EnumType:      transEnumType,
		ArrayType:     transArrayType,
		ArrayDims:     transArrayDims,
		MapType:       transMapType,
		ObjectFields:  transObjectFields,
	}
}

// Fully resolved literal value.
//
// The selected payload is determined by `kind`:
// - `string` -> `stringValue`
// - `int` -> `intValue`
// - `float` -> `floatValue`
// - `bool` -> `boolValue`
// - `object` -> `objectEntries`
// - `array` -> `arrayItems`
type Value struct {
	// Value category discriminator
	Kind ValueKind `json:"kind"`
	// Payload for `kind = string`
	StringValue *string `json:"stringValue,omitempty"`
	// Payload for `kind = int`
	IntValue *int64 `json:"intValue,omitempty"`
	// Payload for `kind = float`
	FloatValue *float64 `json:"floatValue,omitempty"`
	// Payload for `kind = bool`
	BoolValue *bool `json:"boolValue,omitempty"`
	// Payload for `kind = object`
	ObjectEntries *[]ObjectEntry `json:"objectEntries,omitempty"`
	// Payload for `kind = array`
	ArrayItems *[]Value `json:"arrayItems,omitempty"`
}

// GetKind returns the value of Kind or the zero value if the receiver or field is nil.
func (x *Value) GetKind() ValueKind {
	if x != nil {
		return x.Kind
	}
	var zero ValueKind
	return zero
}

// GetKindOr returns the value of Kind or the provided default if the receiver or field is nil.
func (x *Value) GetKindOr(defaultValue ValueKind) ValueKind {
	if x != nil {
		return x.Kind
	}
	return defaultValue
}

// GetStringValue returns the value of StringValue or the zero value if the receiver or field is nil.
func (x *Value) GetStringValue() string {
	if x != nil && x.StringValue != nil {
		return *x.StringValue
	}
	var zero string
	return zero
}

// GetStringValueOr returns the value of StringValue or the provided default if the receiver or field is nil.
func (x *Value) GetStringValueOr(defaultValue string) string {
	if x != nil && x.StringValue != nil {
		return *x.StringValue
	}
	return defaultValue
}

// GetIntValue returns the value of IntValue or the zero value if the receiver or field is nil.
func (x *Value) GetIntValue() int64 {
	if x != nil && x.IntValue != nil {
		return *x.IntValue
	}
	var zero int64
	return zero
}

// GetIntValueOr returns the value of IntValue or the provided default if the receiver or field is nil.
func (x *Value) GetIntValueOr(defaultValue int64) int64 {
	if x != nil && x.IntValue != nil {
		return *x.IntValue
	}
	return defaultValue
}

// GetFloatValue returns the value of FloatValue or the zero value if the receiver or field is nil.
func (x *Value) GetFloatValue() float64 {
	if x != nil && x.FloatValue != nil {
		return *x.FloatValue
	}
	var zero float64
	return zero
}

// GetFloatValueOr returns the value of FloatValue or the provided default if the receiver or field is nil.
func (x *Value) GetFloatValueOr(defaultValue float64) float64 {
	if x != nil && x.FloatValue != nil {
		return *x.FloatValue
	}
	return defaultValue
}

// GetBoolValue returns the value of BoolValue or the zero value if the receiver or field is nil.
func (x *Value) GetBoolValue() bool {
	if x != nil && x.BoolValue != nil {
		return *x.BoolValue
	}
	var zero bool
	return zero
}

// GetBoolValueOr returns the value of BoolValue or the provided default if the receiver or field is nil.
func (x *Value) GetBoolValueOr(defaultValue bool) bool {
	if x != nil && x.BoolValue != nil {
		return *x.BoolValue
	}
	return defaultValue
}

// GetObjectEntries returns the value of ObjectEntries or the zero value if the receiver or field is nil.
func (x *Value) GetObjectEntries() []ObjectEntry {
	if x != nil && x.ObjectEntries != nil {
		return *x.ObjectEntries
	}
	var zero []ObjectEntry
	return zero
}

// GetObjectEntriesOr returns the value of ObjectEntries or the provided default if the receiver or field is nil.
func (x *Value) GetObjectEntriesOr(defaultValue []ObjectEntry) []ObjectEntry {
	if x != nil && x.ObjectEntries != nil {
		return *x.ObjectEntries
	}
	return defaultValue
}

// GetArrayItems returns the value of ArrayItems or the zero value if the receiver or field is nil.
func (x *Value) GetArrayItems() []Value {
	if x != nil && x.ArrayItems != nil {
		return *x.ArrayItems
	}
	var zero []Value
	return zero
}

// GetArrayItemsOr returns the value of ArrayItems or the provided default if the receiver or field is nil.
func (x *Value) GetArrayItemsOr(defaultValue []Value) []Value {
	if x != nil && x.ArrayItems != nil {
		return *x.ArrayItems
	}
	return defaultValue
}

// preValue is the version of Value previous to the required field validation
type preValue struct {
	Kind          *ValueKind        `json:"kind,omitempty"`
	StringValue   *string           `json:"stringValue,omitempty"`
	IntValue      *int64            `json:"intValue,omitempty"`
	FloatValue    *float64          `json:"floatValue,omitempty"`
	BoolValue     *bool             `json:"boolValue,omitempty"`
	ObjectEntries *[]preObjectEntry `json:"objectEntries,omitempty"`
	ArrayItems    *[]preValue       `json:"arrayItems,omitempty"`
}

// validate validates the required fields of Value
func (p *preValue) validate() error {
	if p == nil {
		return errorMissingRequiredField("preValue is nil")
	}

	// Validation for field "kind"
	if p.Kind == nil {
		return errorMissingRequiredField("field kind is required")
	}

	// Validation for field "stringValue"

	// Validation for field "intValue"

	// Validation for field "floatValue"

	// Validation for field "boolValue"

	// Validation for field "objectEntries"
	if p.ObjectEntries != nil {
		for _, item := range *p.ObjectEntries {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field objectEntries: " + err.Error())
			}
		}
	}

	// Validation for field "arrayItems"
	if p.ArrayItems != nil {
		for _, item := range *p.ArrayItems {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field arrayItems: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preValue type to the final Value type
func (p *preValue) transform() Value {
	// Transformations
	transKind := *p.Kind
	transStringValue := p.StringValue
	transIntValue := p.IntValue
	transFloatValue := p.FloatValue
	transBoolValue := p.BoolValue
	var transObjectEntries *[]ObjectEntry
	if p.ObjectEntries != nil {
		var valObjectEntries []ObjectEntry
		valObjectEntries = make([]ObjectEntry, len(*p.ObjectEntries))
		for i, v := range *p.ObjectEntries {
			var tmp_ ObjectEntry
			tmp_ = v.transform()
			valObjectEntries[i] = tmp_
		}
		transObjectEntries = &valObjectEntries
	}
	var transArrayItems *[]Value
	if p.ArrayItems != nil {
		var valArrayItems []Value
		valArrayItems = make([]Value, len(*p.ArrayItems))
		for i, v := range *p.ArrayItems {
			var tmp_ Value
			tmp_ = v.transform()
			valArrayItems[i] = tmp_
		}
		transArrayItems = &valArrayItems
	}

	// Assignments
	return Value{
		Kind:          transKind,
		StringValue:   transStringValue,
		IntValue:      transIntValue,
		FloatValue:    transFloatValue,
		BoolValue:     transBoolValue,
		ObjectEntries: transObjectEntries,
		ArrayItems:    transArrayItems,
	}
}
