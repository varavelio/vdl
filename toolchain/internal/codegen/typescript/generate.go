package typescript

import (
	"context"
	"fmt"
	"strings"

	"github.com/varavelio/gen"
	"github.com/varavelio/vdl/toolchain/internal/codegen/config"
	"github.com/varavelio/vdl/toolchain/internal/codegen/config/configtypes"
	"github.com/varavelio/vdl/toolchain/internal/core/ir/irtypes"
	"github.com/varavelio/vdl/toolchain/internal/util/strutil"
	"github.com/varavelio/vdl/toolchain/internal/version"
)

// File represents a generated file.
type File struct {
	RelativePath string
	Content      []byte
}

// Generator implements the TypeScript code generator.
type Generator struct {
	config *configtypes.TypeScriptConfig
}

// New creates a new TypeScript generator with the given config.
func New(config *configtypes.TypeScriptConfig) *Generator {
	return &Generator{config: config}
}

// Name returns the generator name.
func (g *Generator) Name() string {
	return "typescript"
}

// FileHeader returns the common documentation header generated for all files
func FileHeader() string {
	b := strings.Builder{}
	fmt.Fprintf(&b, "// Code generated by VDL v%s. DO NOT EDIT.\n", version.Version)
	b.WriteString("// If you edit this file, it will be overwritten the next time it is generated.\n")
	b.WriteString("//\n")
	b.WriteString("// For more information about VDL, visit https://vdl.varavel.com\n")
	b.WriteString("\n")

	b.WriteString("/* eslint-disable */\n")
	b.WriteString("/* tslint:disable */\n")
	b.WriteString("// biome-ignore-all lint: Generated by VDL\n")
	b.WriteString("\n")

	return b.String()
}

// Generate produces TypeScript source files from the IR schema.
func (g *Generator) Generate(ctx context.Context, schema *irtypes.IrSchema) ([]File, error) {
	var files []File

	// Track which optional files are generated
	hasConstants := false
	hasPatterns := false

	// Helper to add standard header to files
	addFile := func(path string, content []byte) {
		fullContent := append([]byte(FileHeader()), content...)
		files = append(files, File{
			RelativePath: path,
			Content:      fullContent,
		})
	}

	// core.ts
	coreContent, err := generateCoreTypes(schema, g.config)
	if err != nil {
		return nil, err
	}
	addFile("core.ts", []byte(coreContent))

	// types.ts
	typesContent, err := generateTypes(schema, g.config)
	if err != nil {
		return nil, err
	}
	addFile("types.ts", []byte(typesContent))

	// constants.ts
	constantsContent, err := generateConstants(schema, g.config)
	if err != nil {
		return nil, err
	}
	if strings.TrimSpace(constantsContent) != "" {
		addFile("constants.ts", []byte(constantsContent))
		hasConstants = true
	}

	// patterns.ts
	patternsContent, err := generatePatterns(schema, g.config)
	if err != nil {
		return nil, err
	}
	if strings.TrimSpace(patternsContent) != "" {
		addFile("patterns.ts", []byte(patternsContent))
		hasPatterns = true
	}

	// catalog.ts
	catalogContent, err := generateCatalog(schema, g.config)
	if err != nil {
		return nil, err
	}
	if strings.TrimSpace(catalogContent) != "" {
		addFile("catalog.ts", []byte(catalogContent))
	}

	// client.ts
	if config.ShouldGenClient(g.config.GenClient) && len(schema.Rpcs) > 0 {
		clientContent, err := generateClient(schema, g.config)
		if err != nil {
			return nil, err
		}
		addFile("client.ts", []byte(clientContent))
	}

	// server.ts
	if config.ShouldGenServer(g.config.GenServer) && len(schema.Rpcs) > 0 {
		serverContent, err := generateServer(schema, g.config)
		if err != nil {
			return nil, err
		}
		addFile("server.ts", []byte(serverContent))

		// adapters/fetch.ts - Universal Web Standards adapter
		fetchAdapterContent, err := generateFetchAdapter(g.config)
		if err != nil {
			return nil, err
		}
		addFile("adapters/fetch.ts", []byte(fetchAdapterContent))

		// adapters/node.ts - Node.js adapter
		nodeAdapterContent, err := generateNodeAdapter(g.config)
		if err != nil {
			return nil, err
		}
		addFile("adapters/node.ts", []byte(nodeAdapterContent))
	}

	// index.ts (Exports everything)
	indexBuilder := gen.New().WithSpaces(2)
	indexBuilder.Line(generateExportAll("./core", g.config))
	indexBuilder.Line(generateExportAll("./types", g.config))
	if hasConstants {
		indexBuilder.Line(generateExportAll("./constants", g.config))
	}
	if hasPatterns {
		indexBuilder.Line(generateExportAll("./patterns", g.config))
	}
	if strings.TrimSpace(catalogContent) != "" {
		indexBuilder.Line(generateExportAll("./catalog", g.config))
	}
	if config.ShouldGenClient(g.config.GenClient) && len(schema.Rpcs) > 0 {
		indexBuilder.Line(generateExportAll("./client", g.config))
	}
	if config.ShouldGenServer(g.config.GenServer) && len(schema.Rpcs) > 0 {
		indexBuilder.Line(generateExportAll("./server", g.config))
	}
	addFile("index.ts", []byte(indexBuilder.String()))

	// Pseudo format generated files
	for i := range files {
		content := string(files[i].Content)
		content = strings.TrimSpace(content)
		content = strutil.LimitConsecutiveNewlines(content, 2)
		content += "\n"
		files[i].Content = []byte(content)
	}

	return files, nil
}
