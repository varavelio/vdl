package typescript

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/varavelio/gen"
	"github.com/varavelio/vdl/toolchain/internal/codegen/config"
	"github.com/varavelio/vdl/toolchain/internal/core/ir"
	"github.com/varavelio/vdl/toolchain/internal/version"
)

// File represents a generated file.
type File struct {
	RelativePath string
	Content      []byte
}

// Generator implements the TypeScript code generator.
type Generator struct {
	config *config.TypeScriptConfig
}

// New creates a new TypeScript generator with the given config.
func New(config *config.TypeScriptConfig) *Generator {
	return &Generator{config: config}
}

// Name returns the generator name.
func (g *Generator) Name() string {
	return "typescript"
}

// Generate produces TypeScript source files from the IR schema.
func (g *Generator) Generate(ctx context.Context, schema *ir.Schema) ([]File, error) {
	var files []File

	// Track which optional files are generated
	hasConstants := false
	hasPatterns := false

	// Helper to add standard header to files
	addFile := func(path string, content []byte) {
		header := fmt.Sprintf("// Code generated by VDL v%s. DO NOT EDIT.\n// If you edit this file, it will be overwritten the next time it is generated.\n//\n// For more information about VDL, visit https://vdl.varavel.com\n\n", version.Version)
		fullContent := append([]byte(header), content...)
		files = append(files, File{
			RelativePath: path,
			Content:      fullContent,
		})
	}

	// 1. coreTypes.ts
	coreContent, err := generateCoreTypes(schema, g.config)
	if err != nil {
		return nil, err
	}
	addFile("coreTypes.ts", []byte(coreContent))

	// 2. types.ts
	typesBuilder := gen.New().WithSpaces(2)
	typesBuilder.Line(formatImport("{ Response }", "./coreTypes", g.config))
	typesBuilder.Break()

	// Helper to append content if not empty
	appendContent := func(builder *gen.Generator, genFunc func(*ir.Schema, *config.TypeScriptConfig) (string, error)) error {
		content, err := genFunc(schema, g.config)
		if err != nil {
			return err
		}
		if strings.TrimSpace(content) != "" {
			builder.Raw(content)
			builder.Break()
		}
		return nil
	}

	if err := appendContent(typesBuilder, generateEnums); err != nil {
		return nil, err
	}
	if err := appendContent(typesBuilder, generateDomainTypes); err != nil {
		return nil, err
	}
	if err := appendContent(typesBuilder, generateProcedureTypes); err != nil {
		return nil, err
	}
	if err := appendContent(typesBuilder, generateStreamTypes); err != nil {
		return nil, err
	}

	addFile("types.ts", []byte(typesBuilder.String()))

	// 3. constants.ts
	constantsBuilder := gen.New().WithSpaces(2)
	if err := appendContent(constantsBuilder, generateConstants); err != nil {
		return nil, err
	}
	if constantsContent := constantsBuilder.String(); strings.TrimSpace(constantsContent) != "" {
		addFile("constants.ts", []byte(constantsContent))
		hasConstants = true
	}

	// 4. patterns.ts
	patternsBuilder := gen.New().WithSpaces(2)
	if err := appendContent(patternsBuilder, generatePatterns); err != nil {
		return nil, err
	}
	if patternsContent := patternsBuilder.String(); strings.TrimSpace(patternsContent) != "" {
		addFile("patterns.ts", []byte(patternsContent))
		hasPatterns = true
	}

	// 5. catalog.ts
	catalogContent, err := generateRPCCatalog(schema, g.config)
	if err != nil {
		return nil, err
	}
	// Add imports to catalog
	catalogBuilder := gen.New().WithSpaces(2)
	catalogBuilder.Line(formatImport("{ OperationDefinition }", "./coreTypes", g.config))
	catalogBuilder.Break()
	catalogBuilder.Raw(catalogContent)

	addFile("catalog.ts", []byte(catalogBuilder.String()))

	// 6. client.ts
	if g.config.GenClient {
		clientContent, err := generateClient(schema, g.config)
		if err != nil {
			return nil, err
		}
		clientBuilder := gen.New().WithSpaces(2)
		clientBuilder.Line(formatImport("{ Response, VdlError, asError, OperationType, OperationDefinition, sleep }", "./coreTypes", g.config))

		typeNames := collectAllTypeNames(schema)
		sort.Strings(typeNames)
		if len(typeNames) > 0 {
			clientBuilder.Line(formatImport(fmt.Sprintf("{ %s }", strings.Join(typeNames, ", ")), "./types", g.config))
		}

		clientBuilder.Line(formatImport("{ VDLProcedures, VDLStreams }", "./catalog", g.config))
		clientBuilder.Break()
		clientBuilder.Raw(clientContent)

		addFile("client.ts", []byte(clientBuilder.String()))
	}

	// 7. server.ts
	if g.config.GenServer {
		serverContent, err := generateServer(schema, g.config)
		if err != nil {
			return nil, err
		}
		serverBuilder := gen.New().WithSpaces(2)
		serverBuilder.Line(formatImport("{ Response, VdlError, asError, OperationDefinition, OperationType }", "./coreTypes", g.config))
		serverBuilder.Line(formatImport("{ VDLProcedures, VDLStreams }", "./catalog", g.config))

		typeNames := collectAllTypeNames(schema)
		sort.Strings(typeNames)
		if len(typeNames) > 0 {
			serverBuilder.Line(formatImport(fmt.Sprintf("{ %s }", strings.Join(typeNames, ", ")), "./types", g.config))
		}
		serverBuilder.Break()
		serverBuilder.Raw(serverContent)

		addFile("server.ts", []byte(serverBuilder.String()))

		// 7.1 adapters/fetch.ts - Universal Web Standards adapter
		fetchAdapterContent, err := generateFetchAdapter(g.config)
		if err != nil {
			return nil, err
		}
		addFile("adapters/fetch.ts", []byte(fetchAdapterContent))

		// 7.2 adapters/node.ts - Node.js adapter
		nodeAdapterContent, err := generateNodeAdapter(g.config)
		if err != nil {
			return nil, err
		}
		addFile("adapters/node.ts", []byte(nodeAdapterContent))
	}

	// 8. index.ts (Exports everything)
	indexBuilder := gen.New().WithSpaces(2)
	indexBuilder.Line(formatExport("./coreTypes", g.config))
	indexBuilder.Line(formatExport("./types", g.config))
	if hasConstants {
		indexBuilder.Line(formatExport("./constants", g.config))
	}
	if hasPatterns {
		indexBuilder.Line(formatExport("./patterns", g.config))
	}
	indexBuilder.Line(formatExport("./catalog", g.config))
	if g.config.GenClient {
		indexBuilder.Line(formatExport("./client", g.config))
	}
	if g.config.GenServer {
		indexBuilder.Line(formatExport("./server", g.config))
	}

	addFile("index.ts", []byte(indexBuilder.String()))

	return files, nil
}
