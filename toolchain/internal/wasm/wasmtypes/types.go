// Code generated by VDL v0.0.0-dev. DO NOT EDIT.
// If you edit this file, it will be overwritten the next time it is generated.

// Package wasmtypes contains generated code for VDL.
//
// For more information about VDL, visit https://vdl.varavel.com
package wasmtypes

import (
	"encoding/json"
	"fmt"
)

// -----------------------------------------------------------------------------
// Enumerations
// -----------------------------------------------------------------------------

// Represents a target for codegen function
type CodegenTarget string

// CodegenTarget enum values
const (
	CodegenTargetGo         CodegenTarget = "Go"
	CodegenTargetTypescript CodegenTarget = "Typescript"
	CodegenTargetDart       CodegenTarget = "Dart"
	CodegenTargetPython     CodegenTarget = "Python"
	CodegenTargetOpenApi    CodegenTarget = "OpenApi"
	CodegenTargetJsonSchema CodegenTarget = "JsonSchema"
)

// CodegenTargetList contains all valid CodegenTarget values.
var CodegenTargetList = []CodegenTarget{
	CodegenTargetGo,
	CodegenTargetTypescript,
	CodegenTargetDart,
	CodegenTargetPython,
	CodegenTargetOpenApi,
	CodegenTargetJsonSchema,
}

// String returns the string representation of CodegenTarget.
func (e CodegenTarget) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid CodegenTarget.
func (e CodegenTarget) IsValid() bool {
	switch e {
	case CodegenTargetGo, CodegenTargetTypescript, CodegenTargetDart, CodegenTargetPython, CodegenTargetOpenApi, CodegenTargetJsonSchema:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid CodegenTarget member.
func (e CodegenTarget) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum CodegenTarget", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid CodegenTarget member.
func (e *CodegenTarget) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := CodegenTarget(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum CodegenTarget", s)
	}

	*e = v
	return nil
}

// Import extension for typescript code generator
type CodegenTypescriptImportExtension string

// CodegenTypescriptImportExtension enum values
const (
	CodegenTypescriptImportExtensionNone CodegenTypescriptImportExtension = "none"
	CodegenTypescriptImportExtensionJs   CodegenTypescriptImportExtension = ".js"
	CodegenTypescriptImportExtensionTs   CodegenTypescriptImportExtension = ".ts"
)

// CodegenTypescriptImportExtensionList contains all valid CodegenTypescriptImportExtension values.
var CodegenTypescriptImportExtensionList = []CodegenTypescriptImportExtension{
	CodegenTypescriptImportExtensionNone,
	CodegenTypescriptImportExtensionJs,
	CodegenTypescriptImportExtensionTs,
}

// String returns the string representation of CodegenTypescriptImportExtension.
func (e CodegenTypescriptImportExtension) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid CodegenTypescriptImportExtension.
func (e CodegenTypescriptImportExtension) IsValid() bool {
	switch e {
	case CodegenTypescriptImportExtensionNone, CodegenTypescriptImportExtensionJs, CodegenTypescriptImportExtensionTs:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid CodegenTypescriptImportExtension member.
func (e CodegenTypescriptImportExtension) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum CodegenTypescriptImportExtension", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid CodegenTypescriptImportExtension member.
func (e *CodegenTypescriptImportExtension) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := CodegenTypescriptImportExtension(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum CodegenTypescriptImportExtension", s)
	}

	*e = v
	return nil
}

// Represents a function to be called via WASM
type WasmFunctionName string

// WasmFunctionName enum values
const (
	WasmFunctionNameExpandTypes   WasmFunctionName = "ExpandTypes"
	WasmFunctionNameExtractType   WasmFunctionName = "ExtractType"
	WasmFunctionNameExtractProc   WasmFunctionName = "ExtractProc"
	WasmFunctionNameExtractStream WasmFunctionName = "ExtractStream"
	WasmFunctionNameCodegen       WasmFunctionName = "Codegen"
)

// WasmFunctionNameList contains all valid WasmFunctionName values.
var WasmFunctionNameList = []WasmFunctionName{
	WasmFunctionNameExpandTypes,
	WasmFunctionNameExtractType,
	WasmFunctionNameExtractProc,
	WasmFunctionNameExtractStream,
	WasmFunctionNameCodegen,
}

// String returns the string representation of WasmFunctionName.
func (e WasmFunctionName) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid WasmFunctionName.
func (e WasmFunctionName) IsValid() bool {
	switch e {
	case WasmFunctionNameExpandTypes, WasmFunctionNameExtractType, WasmFunctionNameExtractProc, WasmFunctionNameExtractStream, WasmFunctionNameCodegen:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid WasmFunctionName member.
func (e WasmFunctionName) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum WasmFunctionName", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid WasmFunctionName member.
func (e *WasmFunctionName) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := WasmFunctionName(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum WasmFunctionName", s)
	}

	*e = v
	return nil
}

// -----------------------------------------------------------------------------
// Domain Types
// -----------------------------------------------------------------------------

// Rrepresents a file generated by codegen function
type CodegenFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

// preCodegenFile is the version of CodegenFile previous to the required field validation
type preCodegenFile struct {
	Path    Optional[string] `json:"path,omitzero"`
	Content Optional[string] `json:"content,omitzero"`
}

// validate validates the required fields of CodegenFile
func (p *preCodegenFile) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenFile is nil")
	}

	// Validation for field "path"
	if !p.Path.Present {
		return errorMissingRequiredField("field path is required")
	}

	// Validation for field "content"
	if !p.Content.Present {
		return errorMissingRequiredField("field content is required")
	}

	return nil
}

// transform transforms the preCodegenFile type to the final CodegenFile type
func (p *preCodegenFile) transform() CodegenFile {
	// Transformations
	transPath := p.Path.Value
	transContent := p.Content.Value

	// Assignments
	return CodegenFile{
		Path:    transPath,
		Content: transContent,
	}
}

// Input for codegen function
type CodegenInput struct {
	// Schema to generate code from
	VdlSchema string `json:"vdlSchema"`
	// Target to generate code for
	Target CodegenTarget `json:"target"`
	// Configuration if the target is Go
	GoConfig Optional[CodegenInputGoConfig] `json:"goConfig,omitzero"`
	// Configuration if the target is Typescript
	TypescriptConfig Optional[CodegenInputTypescriptConfig] `json:"typescriptConfig,omitzero"`
	// Configuration if the target is Dart
	DartConfig Optional[CodegenInputDartConfig] `json:"dartConfig,omitzero"`
	// Configuration if the target is Python
	PythonConfig Optional[CodegenInputPythonConfig] `json:"pythonConfig,omitzero"`
	// Configuration if the target is JsonSchema
	JsonSchemaConfig Optional[CodegenInputJsonSchemaConfig] `json:"jsonSchemaConfig,omitzero"`
	// Configuration if the target is OpenApi
	OpenApiConfig Optional[CodegenInputOpenApiConfig] `json:"openApiConfig,omitzero"`
}

type CodegenInputGoConfig struct {
	Package     string `json:"package"`
	GenPatterns bool   `json:"genPatterns"`
	GenConsts   bool   `json:"genConsts"`
	GenClient   bool   `json:"genClient"`
	GenServer   bool   `json:"genServer"`
}

type CodegenInputTypescriptConfig struct {
	ImportExtension CodegenTypescriptImportExtension `json:"importExtension"`
	GenPatterns     bool                             `json:"genPatterns"`
	GenConsts       bool                             `json:"genConsts"`
	GenClient       bool                             `json:"genClient"`
	GenServer       bool                             `json:"genServer"`
}

type CodegenInputDartConfig struct {
	GenPatterns bool `json:"genPatterns"`
	GenConsts   bool `json:"genConsts"`
}

type CodegenInputPythonConfig struct {
	GenPatterns bool `json:"genPatterns"`
	GenConsts   bool `json:"genConsts"`
}

type CodegenInputJsonSchemaConfig struct {
	SchemaId string `json:"schemaId"`
}

type CodegenInputOpenApiConfig struct {
	Title        string           `json:"title"`
	Version      string           `json:"version"`
	Description  Optional[string] `json:"description,omitzero"`
	BaseUrl      Optional[string] `json:"baseUrl,omitzero"`
	ContactName  Optional[string] `json:"contactName,omitzero"`
	ContactEmail Optional[string] `json:"contactEmail,omitzero"`
	LicenseName  Optional[string] `json:"licenseName,omitzero"`
}

// preCodegenInput is the version of CodegenInput previous to the required field validation
type preCodegenInput struct {
	VdlSchema        Optional[string]                          `json:"vdlSchema,omitzero"`
	Target           Optional[CodegenTarget]                   `json:"target,omitzero"`
	GoConfig         Optional[preCodegenInputGoConfig]         `json:"goConfig,omitzero"`
	TypescriptConfig Optional[preCodegenInputTypescriptConfig] `json:"typescriptConfig,omitzero"`
	DartConfig       Optional[preCodegenInputDartConfig]       `json:"dartConfig,omitzero"`
	PythonConfig     Optional[preCodegenInputPythonConfig]     `json:"pythonConfig,omitzero"`
	JsonSchemaConfig Optional[preCodegenInputJsonSchemaConfig] `json:"jsonSchemaConfig,omitzero"`
	OpenApiConfig    Optional[preCodegenInputOpenApiConfig]    `json:"openApiConfig,omitzero"`
}

// preCodegenInputGoConfig is the version of CodegenInputGoConfig previous to the required field validation
type preCodegenInputGoConfig struct {
	Package     Optional[string] `json:"package,omitzero"`
	GenPatterns Optional[bool]   `json:"genPatterns,omitzero"`
	GenConsts   Optional[bool]   `json:"genConsts,omitzero"`
	GenClient   Optional[bool]   `json:"genClient,omitzero"`
	GenServer   Optional[bool]   `json:"genServer,omitzero"`
}

// validate validates the required fields of CodegenInputGoConfig
func (p *preCodegenInputGoConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenInputGoConfig is nil")
	}

	// Validation for field "package"
	if !p.Package.Present {
		return errorMissingRequiredField("field package is required")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	// Validation for field "genClient"
	if !p.GenClient.Present {
		return errorMissingRequiredField("field genClient is required")
	}

	// Validation for field "genServer"
	if !p.GenServer.Present {
		return errorMissingRequiredField("field genServer is required")
	}

	return nil
}

// transform transforms the preCodegenInputGoConfig type to the final CodegenInputGoConfig type
func (p *preCodegenInputGoConfig) transform() CodegenInputGoConfig {
	// Transformations
	transPackage := p.Package.Value
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value
	transGenClient := p.GenClient.Value
	transGenServer := p.GenServer.Value

	// Assignments
	return CodegenInputGoConfig{
		Package:     transPackage,
		GenPatterns: transGenPatterns,
		GenConsts:   transGenConsts,
		GenClient:   transGenClient,
		GenServer:   transGenServer,
	}
}

// preCodegenInputTypescriptConfig is the version of CodegenInputTypescriptConfig previous to the required field validation
type preCodegenInputTypescriptConfig struct {
	ImportExtension Optional[CodegenTypescriptImportExtension] `json:"importExtension,omitzero"`
	GenPatterns     Optional[bool]                             `json:"genPatterns,omitzero"`
	GenConsts       Optional[bool]                             `json:"genConsts,omitzero"`
	GenClient       Optional[bool]                             `json:"genClient,omitzero"`
	GenServer       Optional[bool]                             `json:"genServer,omitzero"`
}

// validate validates the required fields of CodegenInputTypescriptConfig
func (p *preCodegenInputTypescriptConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenInputTypescriptConfig is nil")
	}

	// Validation for field "importExtension"
	if !p.ImportExtension.Present {
		return errorMissingRequiredField("field importExtension is required")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	// Validation for field "genClient"
	if !p.GenClient.Present {
		return errorMissingRequiredField("field genClient is required")
	}

	// Validation for field "genServer"
	if !p.GenServer.Present {
		return errorMissingRequiredField("field genServer is required")
	}

	return nil
}

// transform transforms the preCodegenInputTypescriptConfig type to the final CodegenInputTypescriptConfig type
func (p *preCodegenInputTypescriptConfig) transform() CodegenInputTypescriptConfig {
	// Transformations
	transImportExtension := p.ImportExtension.Value
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value
	transGenClient := p.GenClient.Value
	transGenServer := p.GenServer.Value

	// Assignments
	return CodegenInputTypescriptConfig{
		ImportExtension: transImportExtension,
		GenPatterns:     transGenPatterns,
		GenConsts:       transGenConsts,
		GenClient:       transGenClient,
		GenServer:       transGenServer,
	}
}

// preCodegenInputDartConfig is the version of CodegenInputDartConfig previous to the required field validation
type preCodegenInputDartConfig struct {
	GenPatterns Optional[bool] `json:"genPatterns,omitzero"`
	GenConsts   Optional[bool] `json:"genConsts,omitzero"`
}

// validate validates the required fields of CodegenInputDartConfig
func (p *preCodegenInputDartConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenInputDartConfig is nil")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	return nil
}

// transform transforms the preCodegenInputDartConfig type to the final CodegenInputDartConfig type
func (p *preCodegenInputDartConfig) transform() CodegenInputDartConfig {
	// Transformations
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value

	// Assignments
	return CodegenInputDartConfig{
		GenPatterns: transGenPatterns,
		GenConsts:   transGenConsts,
	}
}

// preCodegenInputPythonConfig is the version of CodegenInputPythonConfig previous to the required field validation
type preCodegenInputPythonConfig struct {
	GenPatterns Optional[bool] `json:"genPatterns,omitzero"`
	GenConsts   Optional[bool] `json:"genConsts,omitzero"`
}

// validate validates the required fields of CodegenInputPythonConfig
func (p *preCodegenInputPythonConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenInputPythonConfig is nil")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	return nil
}

// transform transforms the preCodegenInputPythonConfig type to the final CodegenInputPythonConfig type
func (p *preCodegenInputPythonConfig) transform() CodegenInputPythonConfig {
	// Transformations
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value

	// Assignments
	return CodegenInputPythonConfig{
		GenPatterns: transGenPatterns,
		GenConsts:   transGenConsts,
	}
}

// preCodegenInputJsonSchemaConfig is the version of CodegenInputJsonSchemaConfig previous to the required field validation
type preCodegenInputJsonSchemaConfig struct {
	SchemaId Optional[string] `json:"schemaId,omitzero"`
}

// validate validates the required fields of CodegenInputJsonSchemaConfig
func (p *preCodegenInputJsonSchemaConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenInputJsonSchemaConfig is nil")
	}

	// Validation for field "schemaId"
	if !p.SchemaId.Present {
		return errorMissingRequiredField("field schemaId is required")
	}

	return nil
}

// transform transforms the preCodegenInputJsonSchemaConfig type to the final CodegenInputJsonSchemaConfig type
func (p *preCodegenInputJsonSchemaConfig) transform() CodegenInputJsonSchemaConfig {
	// Transformations
	transSchemaId := p.SchemaId.Value

	// Assignments
	return CodegenInputJsonSchemaConfig{
		SchemaId: transSchemaId,
	}
}

// preCodegenInputOpenApiConfig is the version of CodegenInputOpenApiConfig previous to the required field validation
type preCodegenInputOpenApiConfig struct {
	Title        Optional[string] `json:"title,omitzero"`
	Version      Optional[string] `json:"version,omitzero"`
	Description  Optional[string] `json:"description,omitzero"`
	BaseUrl      Optional[string] `json:"baseUrl,omitzero"`
	ContactName  Optional[string] `json:"contactName,omitzero"`
	ContactEmail Optional[string] `json:"contactEmail,omitzero"`
	LicenseName  Optional[string] `json:"licenseName,omitzero"`
}

// validate validates the required fields of CodegenInputOpenApiConfig
func (p *preCodegenInputOpenApiConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenInputOpenApiConfig is nil")
	}

	// Validation for field "title"
	if !p.Title.Present {
		return errorMissingRequiredField("field title is required")
	}

	// Validation for field "version"
	if !p.Version.Present {
		return errorMissingRequiredField("field version is required")
	}

	// Validation for field "description"

	// Validation for field "baseUrl"

	// Validation for field "contactName"

	// Validation for field "contactEmail"

	// Validation for field "licenseName"

	return nil
}

// transform transforms the preCodegenInputOpenApiConfig type to the final CodegenInputOpenApiConfig type
func (p *preCodegenInputOpenApiConfig) transform() CodegenInputOpenApiConfig {
	// Transformations
	transTitle := p.Title.Value
	transVersion := p.Version.Value
	transDescription := p.Description
	transBaseUrl := p.BaseUrl
	transContactName := p.ContactName
	transContactEmail := p.ContactEmail
	transLicenseName := p.LicenseName

	// Assignments
	return CodegenInputOpenApiConfig{
		Title:        transTitle,
		Version:      transVersion,
		Description:  transDescription,
		BaseUrl:      transBaseUrl,
		ContactName:  transContactName,
		ContactEmail: transContactEmail,
		LicenseName:  transLicenseName,
	}
}

// validate validates the required fields of CodegenInput
func (p *preCodegenInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "target"
	if !p.Target.Present {
		return errorMissingRequiredField("field target is required")
	}

	// Validation for field "goConfig"
	if p.GoConfig.Present {
		if err := p.GoConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field goConfig: " + err.Error())
		}
	}

	// Validation for field "typescriptConfig"
	if p.TypescriptConfig.Present {
		if err := p.TypescriptConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field typescriptConfig: " + err.Error())
		}
	}

	// Validation for field "dartConfig"
	if p.DartConfig.Present {
		if err := p.DartConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field dartConfig: " + err.Error())
		}
	}

	// Validation for field "pythonConfig"
	if p.PythonConfig.Present {
		if err := p.PythonConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field pythonConfig: " + err.Error())
		}
	}

	// Validation for field "jsonSchemaConfig"
	if p.JsonSchemaConfig.Present {
		if err := p.JsonSchemaConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field jsonSchemaConfig: " + err.Error())
		}
	}

	// Validation for field "openApiConfig"
	if p.OpenApiConfig.Present {
		if err := p.OpenApiConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field openApiConfig: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preCodegenInput type to the final CodegenInput type
func (p *preCodegenInput) transform() CodegenInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transTarget := p.Target.Value
	transGoConfig := Optional[CodegenInputGoConfig]{Present: p.GoConfig.Present}
	if p.GoConfig.Present {
		var valGoConfig CodegenInputGoConfig
		valGoConfig = p.GoConfig.Value.transform()
		transGoConfig.Value = valGoConfig
	}
	transTypescriptConfig := Optional[CodegenInputTypescriptConfig]{Present: p.TypescriptConfig.Present}
	if p.TypescriptConfig.Present {
		var valTypescriptConfig CodegenInputTypescriptConfig
		valTypescriptConfig = p.TypescriptConfig.Value.transform()
		transTypescriptConfig.Value = valTypescriptConfig
	}
	transDartConfig := Optional[CodegenInputDartConfig]{Present: p.DartConfig.Present}
	if p.DartConfig.Present {
		var valDartConfig CodegenInputDartConfig
		valDartConfig = p.DartConfig.Value.transform()
		transDartConfig.Value = valDartConfig
	}
	transPythonConfig := Optional[CodegenInputPythonConfig]{Present: p.PythonConfig.Present}
	if p.PythonConfig.Present {
		var valPythonConfig CodegenInputPythonConfig
		valPythonConfig = p.PythonConfig.Value.transform()
		transPythonConfig.Value = valPythonConfig
	}
	transJsonSchemaConfig := Optional[CodegenInputJsonSchemaConfig]{Present: p.JsonSchemaConfig.Present}
	if p.JsonSchemaConfig.Present {
		var valJsonSchemaConfig CodegenInputJsonSchemaConfig
		valJsonSchemaConfig = p.JsonSchemaConfig.Value.transform()
		transJsonSchemaConfig.Value = valJsonSchemaConfig
	}
	transOpenApiConfig := Optional[CodegenInputOpenApiConfig]{Present: p.OpenApiConfig.Present}
	if p.OpenApiConfig.Present {
		var valOpenApiConfig CodegenInputOpenApiConfig
		valOpenApiConfig = p.OpenApiConfig.Value.transform()
		transOpenApiConfig.Value = valOpenApiConfig
	}

	// Assignments
	return CodegenInput{
		VdlSchema:        transVdlSchema,
		Target:           transTarget,
		GoConfig:         transGoConfig,
		TypescriptConfig: transTypescriptConfig,
		DartConfig:       transDartConfig,
		PythonConfig:     transPythonConfig,
		JsonSchemaConfig: transJsonSchemaConfig,
		OpenApiConfig:    transOpenApiConfig,
	}
}

// Output for codegen function
type CodegenOutput struct {
	// The files generated for the picked code generator target
	Files []CodegenFile `json:"files"`
}

// preCodegenOutput is the version of CodegenOutput previous to the required field validation
type preCodegenOutput struct {
	Files Optional[[]preCodegenFile] `json:"files,omitzero"`
}

// validate validates the required fields of CodegenOutput
func (p *preCodegenOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preCodegenOutput is nil")
	}

	// Validation for field "files"
	if !p.Files.Present {
		return errorMissingRequiredField("field files is required")
	}
	if p.Files.Present {
		for _, item := range p.Files.Value {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field files: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preCodegenOutput type to the final CodegenOutput type
func (p *preCodegenOutput) transform() CodegenOutput {
	// Transformations
	var transFiles []CodegenFile
	transFiles = make([]CodegenFile, len(p.Files.Value))
	for i, v := range p.Files.Value {
		var tmp_ CodegenFile
		tmp_ = v.transform()
		transFiles[i] = tmp_
	}

	// Assignments
	return CodegenOutput{
		Files: transFiles,
	}
}

// Input for expandTypes function
type ExpandTypesInput struct {
	VdlSchema string `json:"vdlSchema"`
}

// preExpandTypesInput is the version of ExpandTypesInput previous to the required field validation
type preExpandTypesInput struct {
	VdlSchema Optional[string] `json:"vdlSchema,omitzero"`
}

// validate validates the required fields of ExpandTypesInput
func (p *preExpandTypesInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExpandTypesInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	return nil
}

// transform transforms the preExpandTypesInput type to the final ExpandTypesInput type
func (p *preExpandTypesInput) transform() ExpandTypesInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value

	// Assignments
	return ExpandTypesInput{
		VdlSchema: transVdlSchema,
	}
}

// Output for expandTypes function
type ExpandTypesOutput struct {
	ExpandedSchema string `json:"expandedSchema"`
}

// preExpandTypesOutput is the version of ExpandTypesOutput previous to the required field validation
type preExpandTypesOutput struct {
	ExpandedSchema Optional[string] `json:"expandedSchema,omitzero"`
}

// validate validates the required fields of ExpandTypesOutput
func (p *preExpandTypesOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExpandTypesOutput is nil")
	}

	// Validation for field "expandedSchema"
	if !p.ExpandedSchema.Present {
		return errorMissingRequiredField("field expandedSchema is required")
	}

	return nil
}

// transform transforms the preExpandTypesOutput type to the final ExpandTypesOutput type
func (p *preExpandTypesOutput) transform() ExpandTypesOutput {
	// Transformations
	transExpandedSchema := p.ExpandedSchema.Value

	// Assignments
	return ExpandTypesOutput{
		ExpandedSchema: transExpandedSchema,
	}
}

// Input for extractProc function
type ExtractProcInput struct {
	VdlSchema string `json:"vdlSchema"`
	RpcName   string `json:"rpcName"`
	ProcName  string `json:"procName"`
}

// preExtractProcInput is the version of ExtractProcInput previous to the required field validation
type preExtractProcInput struct {
	VdlSchema Optional[string] `json:"vdlSchema,omitzero"`
	RpcName   Optional[string] `json:"rpcName,omitzero"`
	ProcName  Optional[string] `json:"procName,omitzero"`
}

// validate validates the required fields of ExtractProcInput
func (p *preExtractProcInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExtractProcInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "rpcName"
	if !p.RpcName.Present {
		return errorMissingRequiredField("field rpcName is required")
	}

	// Validation for field "procName"
	if !p.ProcName.Present {
		return errorMissingRequiredField("field procName is required")
	}

	return nil
}

// transform transforms the preExtractProcInput type to the final ExtractProcInput type
func (p *preExtractProcInput) transform() ExtractProcInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transRpcName := p.RpcName.Value
	transProcName := p.ProcName.Value

	// Assignments
	return ExtractProcInput{
		VdlSchema: transVdlSchema,
		RpcName:   transRpcName,
		ProcName:  transProcName,
	}
}

// Output for extractProc function
type ExtractProcOutput struct {
	ProcSchema string `json:"procSchema"`
}

// preExtractProcOutput is the version of ExtractProcOutput previous to the required field validation
type preExtractProcOutput struct {
	ProcSchema Optional[string] `json:"procSchema,omitzero"`
}

// validate validates the required fields of ExtractProcOutput
func (p *preExtractProcOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExtractProcOutput is nil")
	}

	// Validation for field "procSchema"
	if !p.ProcSchema.Present {
		return errorMissingRequiredField("field procSchema is required")
	}

	return nil
}

// transform transforms the preExtractProcOutput type to the final ExtractProcOutput type
func (p *preExtractProcOutput) transform() ExtractProcOutput {
	// Transformations
	transProcSchema := p.ProcSchema.Value

	// Assignments
	return ExtractProcOutput{
		ProcSchema: transProcSchema,
	}
}

// Input for extractStream function
type ExtractStreamInput struct {
	VdlSchema  string `json:"vdlSchema"`
	RpcName    string `json:"rpcName"`
	StreamName string `json:"streamName"`
}

// preExtractStreamInput is the version of ExtractStreamInput previous to the required field validation
type preExtractStreamInput struct {
	VdlSchema  Optional[string] `json:"vdlSchema,omitzero"`
	RpcName    Optional[string] `json:"rpcName,omitzero"`
	StreamName Optional[string] `json:"streamName,omitzero"`
}

// validate validates the required fields of ExtractStreamInput
func (p *preExtractStreamInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExtractStreamInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "rpcName"
	if !p.RpcName.Present {
		return errorMissingRequiredField("field rpcName is required")
	}

	// Validation for field "streamName"
	if !p.StreamName.Present {
		return errorMissingRequiredField("field streamName is required")
	}

	return nil
}

// transform transforms the preExtractStreamInput type to the final ExtractStreamInput type
func (p *preExtractStreamInput) transform() ExtractStreamInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transRpcName := p.RpcName.Value
	transStreamName := p.StreamName.Value

	// Assignments
	return ExtractStreamInput{
		VdlSchema:  transVdlSchema,
		RpcName:    transRpcName,
		StreamName: transStreamName,
	}
}

// Output for extractStream function
type ExtractStreamOutput struct {
	StreamSchema string `json:"streamSchema"`
}

// preExtractStreamOutput is the version of ExtractStreamOutput previous to the required field validation
type preExtractStreamOutput struct {
	StreamSchema Optional[string] `json:"streamSchema,omitzero"`
}

// validate validates the required fields of ExtractStreamOutput
func (p *preExtractStreamOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExtractStreamOutput is nil")
	}

	// Validation for field "streamSchema"
	if !p.StreamSchema.Present {
		return errorMissingRequiredField("field streamSchema is required")
	}

	return nil
}

// transform transforms the preExtractStreamOutput type to the final ExtractStreamOutput type
func (p *preExtractStreamOutput) transform() ExtractStreamOutput {
	// Transformations
	transStreamSchema := p.StreamSchema.Value

	// Assignments
	return ExtractStreamOutput{
		StreamSchema: transStreamSchema,
	}
}

// Input for extractType function
type ExtractTypeInput struct {
	VdlSchema string `json:"vdlSchema"`
	TypeName  string `json:"typeName"`
}

// preExtractTypeInput is the version of ExtractTypeInput previous to the required field validation
type preExtractTypeInput struct {
	VdlSchema Optional[string] `json:"vdlSchema,omitzero"`
	TypeName  Optional[string] `json:"typeName,omitzero"`
}

// validate validates the required fields of ExtractTypeInput
func (p *preExtractTypeInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExtractTypeInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "typeName"
	if !p.TypeName.Present {
		return errorMissingRequiredField("field typeName is required")
	}

	return nil
}

// transform transforms the preExtractTypeInput type to the final ExtractTypeInput type
func (p *preExtractTypeInput) transform() ExtractTypeInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transTypeName := p.TypeName.Value

	// Assignments
	return ExtractTypeInput{
		VdlSchema: transVdlSchema,
		TypeName:  transTypeName,
	}
}

// Output for extractType function
type ExtractTypeOutput struct {
	TypeSchema string `json:"typeSchema"`
}

// preExtractTypeOutput is the version of ExtractTypeOutput previous to the required field validation
type preExtractTypeOutput struct {
	TypeSchema Optional[string] `json:"typeSchema,omitzero"`
}

// validate validates the required fields of ExtractTypeOutput
func (p *preExtractTypeOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preExtractTypeOutput is nil")
	}

	// Validation for field "typeSchema"
	if !p.TypeSchema.Present {
		return errorMissingRequiredField("field typeSchema is required")
	}

	return nil
}

// transform transforms the preExtractTypeOutput type to the final ExtractTypeOutput type
func (p *preExtractTypeOutput) transform() ExtractTypeOutput {
	// Transformations
	transTypeSchema := p.TypeSchema.Value

	// Assignments
	return ExtractTypeOutput{
		TypeSchema: transTypeSchema,
	}
}

// The input for the WASM function call
type WasmInput struct {
	FunctionName  WasmFunctionName             `json:"functionName"`
	ExpandTypes   Optional[ExpandTypesInput]   `json:"expandTypes,omitzero"`
	ExtractType   Optional[ExtractTypeInput]   `json:"extractType,omitzero"`
	ExtractProc   Optional[ExtractProcInput]   `json:"extractProc,omitzero"`
	ExtractStream Optional[ExtractStreamInput] `json:"extractStream,omitzero"`
	Codegen       Optional[CodegenInput]       `json:"codegen,omitzero"`
}

// preWasmInput is the version of WasmInput previous to the required field validation
type preWasmInput struct {
	FunctionName  Optional[WasmFunctionName]      `json:"functionName,omitzero"`
	ExpandTypes   Optional[preExpandTypesInput]   `json:"expandTypes,omitzero"`
	ExtractType   Optional[preExtractTypeInput]   `json:"extractType,omitzero"`
	ExtractProc   Optional[preExtractProcInput]   `json:"extractProc,omitzero"`
	ExtractStream Optional[preExtractStreamInput] `json:"extractStream,omitzero"`
	Codegen       Optional[preCodegenInput]       `json:"codegen,omitzero"`
}

// validate validates the required fields of WasmInput
func (p *preWasmInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmInput is nil")
	}

	// Validation for field "functionName"
	if !p.FunctionName.Present {
		return errorMissingRequiredField("field functionName is required")
	}

	// Validation for field "expandTypes"
	if p.ExpandTypes.Present {
		if err := p.ExpandTypes.Value.validate(); err != nil {
			return errorMissingRequiredField("field expandTypes: " + err.Error())
		}
	}

	// Validation for field "extractType"
	if p.ExtractType.Present {
		if err := p.ExtractType.Value.validate(); err != nil {
			return errorMissingRequiredField("field extractType: " + err.Error())
		}
	}

	// Validation for field "extractProc"
	if p.ExtractProc.Present {
		if err := p.ExtractProc.Value.validate(); err != nil {
			return errorMissingRequiredField("field extractProc: " + err.Error())
		}
	}

	// Validation for field "extractStream"
	if p.ExtractStream.Present {
		if err := p.ExtractStream.Value.validate(); err != nil {
			return errorMissingRequiredField("field extractStream: " + err.Error())
		}
	}

	// Validation for field "codegen"
	if p.Codegen.Present {
		if err := p.Codegen.Value.validate(); err != nil {
			return errorMissingRequiredField("field codegen: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preWasmInput type to the final WasmInput type
func (p *preWasmInput) transform() WasmInput {
	// Transformations
	transFunctionName := p.FunctionName.Value
	transExpandTypes := Optional[ExpandTypesInput]{Present: p.ExpandTypes.Present}
	if p.ExpandTypes.Present {
		var valExpandTypes ExpandTypesInput
		valExpandTypes = p.ExpandTypes.Value.transform()
		transExpandTypes.Value = valExpandTypes
	}
	transExtractType := Optional[ExtractTypeInput]{Present: p.ExtractType.Present}
	if p.ExtractType.Present {
		var valExtractType ExtractTypeInput
		valExtractType = p.ExtractType.Value.transform()
		transExtractType.Value = valExtractType
	}
	transExtractProc := Optional[ExtractProcInput]{Present: p.ExtractProc.Present}
	if p.ExtractProc.Present {
		var valExtractProc ExtractProcInput
		valExtractProc = p.ExtractProc.Value.transform()
		transExtractProc.Value = valExtractProc
	}
	transExtractStream := Optional[ExtractStreamInput]{Present: p.ExtractStream.Present}
	if p.ExtractStream.Present {
		var valExtractStream ExtractStreamInput
		valExtractStream = p.ExtractStream.Value.transform()
		transExtractStream.Value = valExtractStream
	}
	transCodegen := Optional[CodegenInput]{Present: p.Codegen.Present}
	if p.Codegen.Present {
		var valCodegen CodegenInput
		valCodegen = p.Codegen.Value.transform()
		transCodegen.Value = valCodegen
	}

	// Assignments
	return WasmInput{
		FunctionName:  transFunctionName,
		ExpandTypes:   transExpandTypes,
		ExtractType:   transExtractType,
		ExtractProc:   transExtractProc,
		ExtractStream: transExtractStream,
		Codegen:       transCodegen,
	}
}

// The output for the WASM function call
type WasmOutput struct {
	ExpandTypes   Optional[ExpandTypesOutput]   `json:"expandTypes,omitzero"`
	ExtractType   Optional[ExtractTypeOutput]   `json:"extractType,omitzero"`
	ExtractProc   Optional[ExtractProcOutput]   `json:"extractProc,omitzero"`
	ExtractStream Optional[ExtractStreamOutput] `json:"extractStream,omitzero"`
	Codegen       Optional[CodegenOutput]       `json:"codegen,omitzero"`
}

// preWasmOutput is the version of WasmOutput previous to the required field validation
type preWasmOutput struct {
	ExpandTypes   Optional[preExpandTypesOutput]   `json:"expandTypes,omitzero"`
	ExtractType   Optional[preExtractTypeOutput]   `json:"extractType,omitzero"`
	ExtractProc   Optional[preExtractProcOutput]   `json:"extractProc,omitzero"`
	ExtractStream Optional[preExtractStreamOutput] `json:"extractStream,omitzero"`
	Codegen       Optional[preCodegenOutput]       `json:"codegen,omitzero"`
}

// validate validates the required fields of WasmOutput
func (p *preWasmOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmOutput is nil")
	}

	// Validation for field "expandTypes"
	if p.ExpandTypes.Present {
		if err := p.ExpandTypes.Value.validate(); err != nil {
			return errorMissingRequiredField("field expandTypes: " + err.Error())
		}
	}

	// Validation for field "extractType"
	if p.ExtractType.Present {
		if err := p.ExtractType.Value.validate(); err != nil {
			return errorMissingRequiredField("field extractType: " + err.Error())
		}
	}

	// Validation for field "extractProc"
	if p.ExtractProc.Present {
		if err := p.ExtractProc.Value.validate(); err != nil {
			return errorMissingRequiredField("field extractProc: " + err.Error())
		}
	}

	// Validation for field "extractStream"
	if p.ExtractStream.Present {
		if err := p.ExtractStream.Value.validate(); err != nil {
			return errorMissingRequiredField("field extractStream: " + err.Error())
		}
	}

	// Validation for field "codegen"
	if p.Codegen.Present {
		if err := p.Codegen.Value.validate(); err != nil {
			return errorMissingRequiredField("field codegen: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preWasmOutput type to the final WasmOutput type
func (p *preWasmOutput) transform() WasmOutput {
	// Transformations
	transExpandTypes := Optional[ExpandTypesOutput]{Present: p.ExpandTypes.Present}
	if p.ExpandTypes.Present {
		var valExpandTypes ExpandTypesOutput
		valExpandTypes = p.ExpandTypes.Value.transform()
		transExpandTypes.Value = valExpandTypes
	}
	transExtractType := Optional[ExtractTypeOutput]{Present: p.ExtractType.Present}
	if p.ExtractType.Present {
		var valExtractType ExtractTypeOutput
		valExtractType = p.ExtractType.Value.transform()
		transExtractType.Value = valExtractType
	}
	transExtractProc := Optional[ExtractProcOutput]{Present: p.ExtractProc.Present}
	if p.ExtractProc.Present {
		var valExtractProc ExtractProcOutput
		valExtractProc = p.ExtractProc.Value.transform()
		transExtractProc.Value = valExtractProc
	}
	transExtractStream := Optional[ExtractStreamOutput]{Present: p.ExtractStream.Present}
	if p.ExtractStream.Present {
		var valExtractStream ExtractStreamOutput
		valExtractStream = p.ExtractStream.Value.transform()
		transExtractStream.Value = valExtractStream
	}
	transCodegen := Optional[CodegenOutput]{Present: p.Codegen.Present}
	if p.Codegen.Present {
		var valCodegen CodegenOutput
		valCodegen = p.Codegen.Value.transform()
		transCodegen.Value = valCodegen
	}

	// Assignments
	return WasmOutput{
		ExpandTypes:   transExpandTypes,
		ExtractType:   transExtractType,
		ExtractProc:   transExtractProc,
		ExtractStream: transExtractStream,
		Codegen:       transCodegen,
	}
}
