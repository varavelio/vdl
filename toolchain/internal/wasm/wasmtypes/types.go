// Code generated by VDL v0.0.0-dev. DO NOT EDIT.
// If you edit this file, it will be overwritten the next time it is generated.

// Package wasmtypes contains generated code for VDL.
//
// For more information about VDL, visit https://vdl.varavel.com
package wasmtypes

import (
	"encoding/json"
	"fmt"
)

// -----------------------------------------------------------------------------
// Enumerations
// -----------------------------------------------------------------------------

// Represents a target for codegen WASM function
type WasmCodegenTarget string

// WasmCodegenTarget enum values
const (
	WasmCodegenTargetGo         WasmCodegenTarget = "Go"
	WasmCodegenTargetTypescript WasmCodegenTarget = "Typescript"
	WasmCodegenTargetDart       WasmCodegenTarget = "Dart"
	WasmCodegenTargetPython     WasmCodegenTarget = "Python"
	WasmCodegenTargetOpenApi    WasmCodegenTarget = "OpenApi"
	WasmCodegenTargetJsonSchema WasmCodegenTarget = "JsonSchema"
)

// WasmCodegenTargetList contains all valid WasmCodegenTarget values.
var WasmCodegenTargetList = []WasmCodegenTarget{
	WasmCodegenTargetGo,
	WasmCodegenTargetTypescript,
	WasmCodegenTargetDart,
	WasmCodegenTargetPython,
	WasmCodegenTargetOpenApi,
	WasmCodegenTargetJsonSchema,
}

// String returns the string representation of WasmCodegenTarget.
func (e WasmCodegenTarget) String() string {
	return string(e)
}

// IsValid returns true if the value is a valid WasmCodegenTarget.
func (e WasmCodegenTarget) IsValid() bool {
	switch e {
	case WasmCodegenTargetGo, WasmCodegenTargetTypescript, WasmCodegenTargetDart, WasmCodegenTargetPython, WasmCodegenTargetOpenApi, WasmCodegenTargetJsonSchema:
		return true
	}
	return false
}

// MarshalJSON implements json.Marshaler.
// Returns an error if the value is not a valid WasmCodegenTarget member.
func (e WasmCodegenTarget) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("cannot marshal invalid value '%s' for enum WasmCodegenTarget", string(e))
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON implements json.Unmarshaler.
// Returns an error if the value is not a valid WasmCodegenTarget member.
func (e *WasmCodegenTarget) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	v := WasmCodegenTarget(s)
	if !v.IsValid() {
		return fmt.Errorf("invalid value '%s' for enum WasmCodegenTarget", s)
	}

	*e = v
	return nil
}

// -----------------------------------------------------------------------------
// Domain Types
// -----------------------------------------------------------------------------

// Rrepresents a file generated by codegen WASM function
type WasmCodegenFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

// preWasmCodegenFile is the version of WasmCodegenFile previous to the required field validation
type preWasmCodegenFile struct {
	Path    Optional[string] `json:"path,omitzero"`
	Content Optional[string] `json:"content,omitzero"`
}

// validate validates the required fields of WasmCodegenFile
func (p *preWasmCodegenFile) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenFile is nil")
	}

	// Validation for field "path"
	if !p.Path.Present {
		return errorMissingRequiredField("field path is required")
	}

	// Validation for field "content"
	if !p.Content.Present {
		return errorMissingRequiredField("field content is required")
	}

	return nil
}

// transform transforms the preWasmCodegenFile type to the final WasmCodegenFile type
func (p *preWasmCodegenFile) transform() WasmCodegenFile {
	// Transformations
	transPath := p.Path.Value
	transContent := p.Content.Value

	// Assignments
	return WasmCodegenFile{
		Path:    transPath,
		Content: transContent,
	}
}

// Input for codegen WASM function
type WasmCodegenInput struct {
	// Schema to generate code from
	VdlSchema string `json:"vdlSchema"`
	// Target to generate code for
	Target WasmCodegenTarget `json:"target"`
	// Configuration if the target is Go
	GoConfig Optional[WasmCodegenInputGoConfig] `json:"goConfig,omitzero"`
	// Configuration if the target is Typescript
	TypescriptConfig Optional[WasmCodegenInputTypescriptConfig] `json:"typescriptConfig,omitzero"`
	// Configuration if the target is Dart
	DartConfig Optional[WasmCodegenInputDartConfig] `json:"dartConfig,omitzero"`
	// Configuration if the target is Python
	PythonConfig Optional[WasmCodegenInputPythonConfig] `json:"pythonConfig,omitzero"`
	// Configuration if the target is JsonSchema
	JsonSchemaConfig Optional[WasmCodegenInputJsonSchemaConfig] `json:"jsonSchemaConfig,omitzero"`
	// Configuration if the target is OpenApi
	OpenApiConfig Optional[WasmCodegenInputOpenApiConfig] `json:"openApiConfig,omitzero"`
}

type WasmCodegenInputGoConfig struct {
	Package     string `json:"package"`
	GenPatterns bool   `json:"genPatterns"`
	GenConsts   bool   `json:"genConsts"`
	GenClient   bool   `json:"genClient"`
	GenServer   bool   `json:"genServer"`
}

type WasmCodegenInputTypescriptConfig struct {
	ImportExtension string `json:"importExtension"`
	GenPatterns     bool   `json:"genPatterns"`
	GenConsts       bool   `json:"genConsts"`
	GenClient       bool   `json:"genClient"`
	GenServer       bool   `json:"genServer"`
}

type WasmCodegenInputDartConfig struct {
	GenPatterns bool `json:"genPatterns"`
	GenConsts   bool `json:"genConsts"`
}

type WasmCodegenInputPythonConfig struct {
	GenPatterns bool `json:"genPatterns"`
	GenConsts   bool `json:"genConsts"`
}

type WasmCodegenInputJsonSchemaConfig struct {
	SchemaId string `json:"schemaId"`
}

type WasmCodegenInputOpenApiConfig struct {
	Title        string           `json:"title"`
	Version      string           `json:"version"`
	Description  Optional[string] `json:"description,omitzero"`
	BaseUrl      Optional[string] `json:"baseUrl,omitzero"`
	ContactName  Optional[string] `json:"contactName,omitzero"`
	ContactEmail Optional[string] `json:"contactEmail,omitzero"`
	LicenseName  Optional[string] `json:"licenseName,omitzero"`
}

// preWasmCodegenInput is the version of WasmCodegenInput previous to the required field validation
type preWasmCodegenInput struct {
	VdlSchema        Optional[string]                              `json:"vdlSchema,omitzero"`
	Target           Optional[WasmCodegenTarget]                   `json:"target,omitzero"`
	GoConfig         Optional[preWasmCodegenInputGoConfig]         `json:"goConfig,omitzero"`
	TypescriptConfig Optional[preWasmCodegenInputTypescriptConfig] `json:"typescriptConfig,omitzero"`
	DartConfig       Optional[preWasmCodegenInputDartConfig]       `json:"dartConfig,omitzero"`
	PythonConfig     Optional[preWasmCodegenInputPythonConfig]     `json:"pythonConfig,omitzero"`
	JsonSchemaConfig Optional[preWasmCodegenInputJsonSchemaConfig] `json:"jsonSchemaConfig,omitzero"`
	OpenApiConfig    Optional[preWasmCodegenInputOpenApiConfig]    `json:"openApiConfig,omitzero"`
}

// preWasmCodegenInputGoConfig is the version of WasmCodegenInputGoConfig previous to the required field validation
type preWasmCodegenInputGoConfig struct {
	Package     Optional[string] `json:"package,omitzero"`
	GenPatterns Optional[bool]   `json:"genPatterns,omitzero"`
	GenConsts   Optional[bool]   `json:"genConsts,omitzero"`
	GenClient   Optional[bool]   `json:"genClient,omitzero"`
	GenServer   Optional[bool]   `json:"genServer,omitzero"`
}

// validate validates the required fields of WasmCodegenInputGoConfig
func (p *preWasmCodegenInputGoConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenInputGoConfig is nil")
	}

	// Validation for field "package"
	if !p.Package.Present {
		return errorMissingRequiredField("field package is required")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	// Validation for field "genClient"
	if !p.GenClient.Present {
		return errorMissingRequiredField("field genClient is required")
	}

	// Validation for field "genServer"
	if !p.GenServer.Present {
		return errorMissingRequiredField("field genServer is required")
	}

	return nil
}

// transform transforms the preWasmCodegenInputGoConfig type to the final WasmCodegenInputGoConfig type
func (p *preWasmCodegenInputGoConfig) transform() WasmCodegenInputGoConfig {
	// Transformations
	transPackage := p.Package.Value
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value
	transGenClient := p.GenClient.Value
	transGenServer := p.GenServer.Value

	// Assignments
	return WasmCodegenInputGoConfig{
		Package:     transPackage,
		GenPatterns: transGenPatterns,
		GenConsts:   transGenConsts,
		GenClient:   transGenClient,
		GenServer:   transGenServer,
	}
}

// preWasmCodegenInputTypescriptConfig is the version of WasmCodegenInputTypescriptConfig previous to the required field validation
type preWasmCodegenInputTypescriptConfig struct {
	ImportExtension Optional[string] `json:"importExtension,omitzero"`
	GenPatterns     Optional[bool]   `json:"genPatterns,omitzero"`
	GenConsts       Optional[bool]   `json:"genConsts,omitzero"`
	GenClient       Optional[bool]   `json:"genClient,omitzero"`
	GenServer       Optional[bool]   `json:"genServer,omitzero"`
}

// validate validates the required fields of WasmCodegenInputTypescriptConfig
func (p *preWasmCodegenInputTypescriptConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenInputTypescriptConfig is nil")
	}

	// Validation for field "importExtension"
	if !p.ImportExtension.Present {
		return errorMissingRequiredField("field importExtension is required")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	// Validation for field "genClient"
	if !p.GenClient.Present {
		return errorMissingRequiredField("field genClient is required")
	}

	// Validation for field "genServer"
	if !p.GenServer.Present {
		return errorMissingRequiredField("field genServer is required")
	}

	return nil
}

// transform transforms the preWasmCodegenInputTypescriptConfig type to the final WasmCodegenInputTypescriptConfig type
func (p *preWasmCodegenInputTypescriptConfig) transform() WasmCodegenInputTypescriptConfig {
	// Transformations
	transImportExtension := p.ImportExtension.Value
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value
	transGenClient := p.GenClient.Value
	transGenServer := p.GenServer.Value

	// Assignments
	return WasmCodegenInputTypescriptConfig{
		ImportExtension: transImportExtension,
		GenPatterns:     transGenPatterns,
		GenConsts:       transGenConsts,
		GenClient:       transGenClient,
		GenServer:       transGenServer,
	}
}

// preWasmCodegenInputDartConfig is the version of WasmCodegenInputDartConfig previous to the required field validation
type preWasmCodegenInputDartConfig struct {
	GenPatterns Optional[bool] `json:"genPatterns,omitzero"`
	GenConsts   Optional[bool] `json:"genConsts,omitzero"`
}

// validate validates the required fields of WasmCodegenInputDartConfig
func (p *preWasmCodegenInputDartConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenInputDartConfig is nil")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	return nil
}

// transform transforms the preWasmCodegenInputDartConfig type to the final WasmCodegenInputDartConfig type
func (p *preWasmCodegenInputDartConfig) transform() WasmCodegenInputDartConfig {
	// Transformations
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value

	// Assignments
	return WasmCodegenInputDartConfig{
		GenPatterns: transGenPatterns,
		GenConsts:   transGenConsts,
	}
}

// preWasmCodegenInputPythonConfig is the version of WasmCodegenInputPythonConfig previous to the required field validation
type preWasmCodegenInputPythonConfig struct {
	GenPatterns Optional[bool] `json:"genPatterns,omitzero"`
	GenConsts   Optional[bool] `json:"genConsts,omitzero"`
}

// validate validates the required fields of WasmCodegenInputPythonConfig
func (p *preWasmCodegenInputPythonConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenInputPythonConfig is nil")
	}

	// Validation for field "genPatterns"
	if !p.GenPatterns.Present {
		return errorMissingRequiredField("field genPatterns is required")
	}

	// Validation for field "genConsts"
	if !p.GenConsts.Present {
		return errorMissingRequiredField("field genConsts is required")
	}

	return nil
}

// transform transforms the preWasmCodegenInputPythonConfig type to the final WasmCodegenInputPythonConfig type
func (p *preWasmCodegenInputPythonConfig) transform() WasmCodegenInputPythonConfig {
	// Transformations
	transGenPatterns := p.GenPatterns.Value
	transGenConsts := p.GenConsts.Value

	// Assignments
	return WasmCodegenInputPythonConfig{
		GenPatterns: transGenPatterns,
		GenConsts:   transGenConsts,
	}
}

// preWasmCodegenInputJsonSchemaConfig is the version of WasmCodegenInputJsonSchemaConfig previous to the required field validation
type preWasmCodegenInputJsonSchemaConfig struct {
	SchemaId Optional[string] `json:"schemaId,omitzero"`
}

// validate validates the required fields of WasmCodegenInputJsonSchemaConfig
func (p *preWasmCodegenInputJsonSchemaConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenInputJsonSchemaConfig is nil")
	}

	// Validation for field "schemaId"
	if !p.SchemaId.Present {
		return errorMissingRequiredField("field schemaId is required")
	}

	return nil
}

// transform transforms the preWasmCodegenInputJsonSchemaConfig type to the final WasmCodegenInputJsonSchemaConfig type
func (p *preWasmCodegenInputJsonSchemaConfig) transform() WasmCodegenInputJsonSchemaConfig {
	// Transformations
	transSchemaId := p.SchemaId.Value

	// Assignments
	return WasmCodegenInputJsonSchemaConfig{
		SchemaId: transSchemaId,
	}
}

// preWasmCodegenInputOpenApiConfig is the version of WasmCodegenInputOpenApiConfig previous to the required field validation
type preWasmCodegenInputOpenApiConfig struct {
	Title        Optional[string] `json:"title,omitzero"`
	Version      Optional[string] `json:"version,omitzero"`
	Description  Optional[string] `json:"description,omitzero"`
	BaseUrl      Optional[string] `json:"baseUrl,omitzero"`
	ContactName  Optional[string] `json:"contactName,omitzero"`
	ContactEmail Optional[string] `json:"contactEmail,omitzero"`
	LicenseName  Optional[string] `json:"licenseName,omitzero"`
}

// validate validates the required fields of WasmCodegenInputOpenApiConfig
func (p *preWasmCodegenInputOpenApiConfig) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenInputOpenApiConfig is nil")
	}

	// Validation for field "title"
	if !p.Title.Present {
		return errorMissingRequiredField("field title is required")
	}

	// Validation for field "version"
	if !p.Version.Present {
		return errorMissingRequiredField("field version is required")
	}

	// Validation for field "description"

	// Validation for field "baseUrl"

	// Validation for field "contactName"

	// Validation for field "contactEmail"

	// Validation for field "licenseName"

	return nil
}

// transform transforms the preWasmCodegenInputOpenApiConfig type to the final WasmCodegenInputOpenApiConfig type
func (p *preWasmCodegenInputOpenApiConfig) transform() WasmCodegenInputOpenApiConfig {
	// Transformations
	transTitle := p.Title.Value
	transVersion := p.Version.Value
	transDescription := p.Description
	transBaseUrl := p.BaseUrl
	transContactName := p.ContactName
	transContactEmail := p.ContactEmail
	transLicenseName := p.LicenseName

	// Assignments
	return WasmCodegenInputOpenApiConfig{
		Title:        transTitle,
		Version:      transVersion,
		Description:  transDescription,
		BaseUrl:      transBaseUrl,
		ContactName:  transContactName,
		ContactEmail: transContactEmail,
		LicenseName:  transLicenseName,
	}
}

// validate validates the required fields of WasmCodegenInput
func (p *preWasmCodegenInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "target"
	if !p.Target.Present {
		return errorMissingRequiredField("field target is required")
	}

	// Validation for field "goConfig"
	if p.GoConfig.Present {
		if err := p.GoConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field goConfig: " + err.Error())
		}
	}

	// Validation for field "typescriptConfig"
	if p.TypescriptConfig.Present {
		if err := p.TypescriptConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field typescriptConfig: " + err.Error())
		}
	}

	// Validation for field "dartConfig"
	if p.DartConfig.Present {
		if err := p.DartConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field dartConfig: " + err.Error())
		}
	}

	// Validation for field "pythonConfig"
	if p.PythonConfig.Present {
		if err := p.PythonConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field pythonConfig: " + err.Error())
		}
	}

	// Validation for field "jsonSchemaConfig"
	if p.JsonSchemaConfig.Present {
		if err := p.JsonSchemaConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field jsonSchemaConfig: " + err.Error())
		}
	}

	// Validation for field "openApiConfig"
	if p.OpenApiConfig.Present {
		if err := p.OpenApiConfig.Value.validate(); err != nil {
			return errorMissingRequiredField("field openApiConfig: " + err.Error())
		}
	}

	return nil
}

// transform transforms the preWasmCodegenInput type to the final WasmCodegenInput type
func (p *preWasmCodegenInput) transform() WasmCodegenInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transTarget := p.Target.Value
	transGoConfig := Optional[WasmCodegenInputGoConfig]{Present: p.GoConfig.Present}
	if p.GoConfig.Present {
		var valGoConfig WasmCodegenInputGoConfig
		valGoConfig = p.GoConfig.Value.transform()
		transGoConfig.Value = valGoConfig
	}
	transTypescriptConfig := Optional[WasmCodegenInputTypescriptConfig]{Present: p.TypescriptConfig.Present}
	if p.TypescriptConfig.Present {
		var valTypescriptConfig WasmCodegenInputTypescriptConfig
		valTypescriptConfig = p.TypescriptConfig.Value.transform()
		transTypescriptConfig.Value = valTypescriptConfig
	}
	transDartConfig := Optional[WasmCodegenInputDartConfig]{Present: p.DartConfig.Present}
	if p.DartConfig.Present {
		var valDartConfig WasmCodegenInputDartConfig
		valDartConfig = p.DartConfig.Value.transform()
		transDartConfig.Value = valDartConfig
	}
	transPythonConfig := Optional[WasmCodegenInputPythonConfig]{Present: p.PythonConfig.Present}
	if p.PythonConfig.Present {
		var valPythonConfig WasmCodegenInputPythonConfig
		valPythonConfig = p.PythonConfig.Value.transform()
		transPythonConfig.Value = valPythonConfig
	}
	transJsonSchemaConfig := Optional[WasmCodegenInputJsonSchemaConfig]{Present: p.JsonSchemaConfig.Present}
	if p.JsonSchemaConfig.Present {
		var valJsonSchemaConfig WasmCodegenInputJsonSchemaConfig
		valJsonSchemaConfig = p.JsonSchemaConfig.Value.transform()
		transJsonSchemaConfig.Value = valJsonSchemaConfig
	}
	transOpenApiConfig := Optional[WasmCodegenInputOpenApiConfig]{Present: p.OpenApiConfig.Present}
	if p.OpenApiConfig.Present {
		var valOpenApiConfig WasmCodegenInputOpenApiConfig
		valOpenApiConfig = p.OpenApiConfig.Value.transform()
		transOpenApiConfig.Value = valOpenApiConfig
	}

	// Assignments
	return WasmCodegenInput{
		VdlSchema:        transVdlSchema,
		Target:           transTarget,
		GoConfig:         transGoConfig,
		TypescriptConfig: transTypescriptConfig,
		DartConfig:       transDartConfig,
		PythonConfig:     transPythonConfig,
		JsonSchemaConfig: transJsonSchemaConfig,
		OpenApiConfig:    transOpenApiConfig,
	}
}

// Output for codegen WASM function
type WasmCodegenOutput struct {
	// The files generated for the picked code generator target
	Files []WasmCodegenFile `json:"files"`
}

// preWasmCodegenOutput is the version of WasmCodegenOutput previous to the required field validation
type preWasmCodegenOutput struct {
	Files Optional[[]preWasmCodegenFile] `json:"files,omitzero"`
}

// validate validates the required fields of WasmCodegenOutput
func (p *preWasmCodegenOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmCodegenOutput is nil")
	}

	// Validation for field "files"
	if !p.Files.Present {
		return errorMissingRequiredField("field files is required")
	}
	if p.Files.Present {
		for _, item := range p.Files.Value {
			if err := item.validate(); err != nil {
				return errorMissingRequiredField("field files: " + err.Error())
			}
		}
	}

	return nil
}

// transform transforms the preWasmCodegenOutput type to the final WasmCodegenOutput type
func (p *preWasmCodegenOutput) transform() WasmCodegenOutput {
	// Transformations
	var transFiles []WasmCodegenFile
	transFiles = make([]WasmCodegenFile, len(p.Files.Value))
	for i, v := range p.Files.Value {
		var tmp_ WasmCodegenFile
		tmp_ = v.transform()
		transFiles[i] = tmp_
	}

	// Assignments
	return WasmCodegenOutput{
		Files: transFiles,
	}
}

// Input for expandTypes WASM function
type WasmExpandTypesInput struct {
	VdlSchema string `json:"vdlSchema"`
}

// preWasmExpandTypesInput is the version of WasmExpandTypesInput previous to the required field validation
type preWasmExpandTypesInput struct {
	VdlSchema Optional[string] `json:"vdlSchema,omitzero"`
}

// validate validates the required fields of WasmExpandTypesInput
func (p *preWasmExpandTypesInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExpandTypesInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	return nil
}

// transform transforms the preWasmExpandTypesInput type to the final WasmExpandTypesInput type
func (p *preWasmExpandTypesInput) transform() WasmExpandTypesInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value

	// Assignments
	return WasmExpandTypesInput{
		VdlSchema: transVdlSchema,
	}
}

// Output for expandTypes WASM function
type WasmExpandTypesOutput struct {
	ExpandedSchema string `json:"expandedSchema"`
}

// preWasmExpandTypesOutput is the version of WasmExpandTypesOutput previous to the required field validation
type preWasmExpandTypesOutput struct {
	ExpandedSchema Optional[string] `json:"expandedSchema,omitzero"`
}

// validate validates the required fields of WasmExpandTypesOutput
func (p *preWasmExpandTypesOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExpandTypesOutput is nil")
	}

	// Validation for field "expandedSchema"
	if !p.ExpandedSchema.Present {
		return errorMissingRequiredField("field expandedSchema is required")
	}

	return nil
}

// transform transforms the preWasmExpandTypesOutput type to the final WasmExpandTypesOutput type
func (p *preWasmExpandTypesOutput) transform() WasmExpandTypesOutput {
	// Transformations
	transExpandedSchema := p.ExpandedSchema.Value

	// Assignments
	return WasmExpandTypesOutput{
		ExpandedSchema: transExpandedSchema,
	}
}

// Input for extractProc WASM function
type WasmExtractProcInput struct {
	VdlSchema string `json:"vdlSchema"`
	RpcName   string `json:"rpcName"`
	ProcName  string `json:"procName"`
}

// preWasmExtractProcInput is the version of WasmExtractProcInput previous to the required field validation
type preWasmExtractProcInput struct {
	VdlSchema Optional[string] `json:"vdlSchema,omitzero"`
	RpcName   Optional[string] `json:"rpcName,omitzero"`
	ProcName  Optional[string] `json:"procName,omitzero"`
}

// validate validates the required fields of WasmExtractProcInput
func (p *preWasmExtractProcInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExtractProcInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "rpcName"
	if !p.RpcName.Present {
		return errorMissingRequiredField("field rpcName is required")
	}

	// Validation for field "procName"
	if !p.ProcName.Present {
		return errorMissingRequiredField("field procName is required")
	}

	return nil
}

// transform transforms the preWasmExtractProcInput type to the final WasmExtractProcInput type
func (p *preWasmExtractProcInput) transform() WasmExtractProcInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transRpcName := p.RpcName.Value
	transProcName := p.ProcName.Value

	// Assignments
	return WasmExtractProcInput{
		VdlSchema: transVdlSchema,
		RpcName:   transRpcName,
		ProcName:  transProcName,
	}
}

// Output for extractProc WASM function
type WasmExtractProcOutput struct {
	ProcSchema string `json:"procSchema"`
}

// preWasmExtractProcOutput is the version of WasmExtractProcOutput previous to the required field validation
type preWasmExtractProcOutput struct {
	ProcSchema Optional[string] `json:"procSchema,omitzero"`
}

// validate validates the required fields of WasmExtractProcOutput
func (p *preWasmExtractProcOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExtractProcOutput is nil")
	}

	// Validation for field "procSchema"
	if !p.ProcSchema.Present {
		return errorMissingRequiredField("field procSchema is required")
	}

	return nil
}

// transform transforms the preWasmExtractProcOutput type to the final WasmExtractProcOutput type
func (p *preWasmExtractProcOutput) transform() WasmExtractProcOutput {
	// Transformations
	transProcSchema := p.ProcSchema.Value

	// Assignments
	return WasmExtractProcOutput{
		ProcSchema: transProcSchema,
	}
}

// Input for extractStream WASM function
type WasmExtractStreamInput struct {
	VdlSchema  string `json:"vdlSchema"`
	RpcName    string `json:"rpcName"`
	StreamName string `json:"streamName"`
}

// preWasmExtractStreamInput is the version of WasmExtractStreamInput previous to the required field validation
type preWasmExtractStreamInput struct {
	VdlSchema  Optional[string] `json:"vdlSchema,omitzero"`
	RpcName    Optional[string] `json:"rpcName,omitzero"`
	StreamName Optional[string] `json:"streamName,omitzero"`
}

// validate validates the required fields of WasmExtractStreamInput
func (p *preWasmExtractStreamInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExtractStreamInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "rpcName"
	if !p.RpcName.Present {
		return errorMissingRequiredField("field rpcName is required")
	}

	// Validation for field "streamName"
	if !p.StreamName.Present {
		return errorMissingRequiredField("field streamName is required")
	}

	return nil
}

// transform transforms the preWasmExtractStreamInput type to the final WasmExtractStreamInput type
func (p *preWasmExtractStreamInput) transform() WasmExtractStreamInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transRpcName := p.RpcName.Value
	transStreamName := p.StreamName.Value

	// Assignments
	return WasmExtractStreamInput{
		VdlSchema:  transVdlSchema,
		RpcName:    transRpcName,
		StreamName: transStreamName,
	}
}

// Output for extractStream WASM function
type WasmExtractStreamOutput struct {
	StreamSchema string `json:"streamSchema"`
}

// preWasmExtractStreamOutput is the version of WasmExtractStreamOutput previous to the required field validation
type preWasmExtractStreamOutput struct {
	StreamSchema Optional[string] `json:"streamSchema,omitzero"`
}

// validate validates the required fields of WasmExtractStreamOutput
func (p *preWasmExtractStreamOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExtractStreamOutput is nil")
	}

	// Validation for field "streamSchema"
	if !p.StreamSchema.Present {
		return errorMissingRequiredField("field streamSchema is required")
	}

	return nil
}

// transform transforms the preWasmExtractStreamOutput type to the final WasmExtractStreamOutput type
func (p *preWasmExtractStreamOutput) transform() WasmExtractStreamOutput {
	// Transformations
	transStreamSchema := p.StreamSchema.Value

	// Assignments
	return WasmExtractStreamOutput{
		StreamSchema: transStreamSchema,
	}
}

// Input for extractType WASM function
type WasmExtractTypeInput struct {
	VdlSchema string `json:"vdlSchema"`
	TypeName  string `json:"typeName"`
}

// preWasmExtractTypeInput is the version of WasmExtractTypeInput previous to the required field validation
type preWasmExtractTypeInput struct {
	VdlSchema Optional[string] `json:"vdlSchema,omitzero"`
	TypeName  Optional[string] `json:"typeName,omitzero"`
}

// validate validates the required fields of WasmExtractTypeInput
func (p *preWasmExtractTypeInput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExtractTypeInput is nil")
	}

	// Validation for field "vdlSchema"
	if !p.VdlSchema.Present {
		return errorMissingRequiredField("field vdlSchema is required")
	}

	// Validation for field "typeName"
	if !p.TypeName.Present {
		return errorMissingRequiredField("field typeName is required")
	}

	return nil
}

// transform transforms the preWasmExtractTypeInput type to the final WasmExtractTypeInput type
func (p *preWasmExtractTypeInput) transform() WasmExtractTypeInput {
	// Transformations
	transVdlSchema := p.VdlSchema.Value
	transTypeName := p.TypeName.Value

	// Assignments
	return WasmExtractTypeInput{
		VdlSchema: transVdlSchema,
		TypeName:  transTypeName,
	}
}

// Output for extractType WASM function
type WasmExtractTypeOutput struct {
	TypeSchema string `json:"typeSchema"`
}

// preWasmExtractTypeOutput is the version of WasmExtractTypeOutput previous to the required field validation
type preWasmExtractTypeOutput struct {
	TypeSchema Optional[string] `json:"typeSchema,omitzero"`
}

// validate validates the required fields of WasmExtractTypeOutput
func (p *preWasmExtractTypeOutput) validate() error {
	if p == nil {
		return errorMissingRequiredField("preWasmExtractTypeOutput is nil")
	}

	// Validation for field "typeSchema"
	if !p.TypeSchema.Present {
		return errorMissingRequiredField("field typeSchema is required")
	}

	return nil
}

// transform transforms the preWasmExtractTypeOutput type to the final WasmExtractTypeOutput type
func (p *preWasmExtractTypeOutput) transform() WasmExtractTypeOutput {
	// Transformations
	transTypeSchema := p.TypeSchema.Value

	// Assignments
	return WasmExtractTypeOutput{
		TypeSchema: transTypeSchema,
	}
}
